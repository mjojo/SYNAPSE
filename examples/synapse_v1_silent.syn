// ============================================================================
// SYNAPSE v1.0 - THE SINGULARITY (SILENT VERSION)
// Self-Hosting Compiler - Phase 55 Step 10
// 
// This version has no debug output to work around JIT string pointer issues.
// It reads "in.syn" and produces "out.exe"
// ============================================================================

// ============================================================================
// SECTION 1: STDLIB CORE
// ============================================================================

fn str_len(s) {
    let i = 0
    while getbyte(s, i) > 0 {
        i = i + 1
    }
    return i
}

fn str_eq(a, b) {
    let i = 0
    let ca = getbyte(a, i)
    let cb = getbyte(b, i)
    while ca > 0 {
        if ca != cb {
            return 0
        }
        i = i + 1
        ca = getbyte(a, i)
        cb = getbyte(b, i)
    }
    if cb > 0 {
        return 0
    }
    return 1
}

fn is_digit(c) {
    if c >= 48 {
        if c <= 57 {
            return 1
        }
    }
    return 0
}

fn is_alpha(c) {
    if c >= 65 {
        if c <= 90 {
            return 1
        }
    }
    if c >= 97 {
        if c <= 122 {
            return 1
        }
    }
    if c == 95 {
        return 1
    }
    return 0
}

fn is_alnum(c) {
    if is_alpha(c) == 1 {
        return 1
    }
    if is_digit(c) == 1 {
        return 1
    }
    return 0
}

// ============================================================================
// SECTION 2: GLOBAL STATE
// ============================================================================

fn init_compiler(state) {
    state[0] = alloc(32768)   // tokens_buf
    state[1] = 0              // tokens_count
    state[2] = 0              // token_pos
    state[3] = alloc(8192)    // code_buf
    state[4] = 0              // code_pos
    state[5] = alloc(16384)   // exe_buf
    state[6] = 0              // exe_pos
    state[7] = alloc(4096)    // data_buf
    state[8] = 0              // data_pos
    state[9] = 0              // source_buf
    state[10] = 0             // source_pos
    state[11] = 0             // source_len
    let vi = 12
    while vi < 28 {
        state[vi] = 0
        vi = vi + 1
    }
    state[28] = 0             // var_count
    state[29] = 0             // stack_depth
    return 0
}

// ============================================================================
// SECTION 3: CODE GENERATION
// ============================================================================

fn emit(state, b) {
    let code_buf = state[3]
    let code_pos = state[4]
    setbyte(code_buf, code_pos, b)
    state[4] = code_pos + 1
    return 0
}

fn emit_dword(state, n) {
    emit(state, n % 256)
    let n1 = n / 256
    emit(state, n1 % 256)
    let n2 = n1 / 256
    emit(state, n2 % 256)
    let n3 = n2 / 256
    emit(state, n3 % 256)
    return 0
}

fn emit_iat_call(state, iat_index) {
    let iat_offset = iat_index * 8
    let target_rva = 8232 + iat_offset
    
    let code_pos = state[4]
    let next_rip = 4096 + code_pos + 6
    
    let disp = target_rva - next_rip
    
    emit(state, 255)
    emit(state, 21)
    emit(state, disp % 256)
    let d1 = disp / 256
    emit(state, d1 % 256)
    let d2 = d1 / 256
    emit(state, d2 % 256)
    let d3 = d2 / 256
    emit(state, d3 % 256)
    return 0
}

fn emit_mov_rax_imm64(state, val) {
    emit(state, 72)
    emit(state, 184)
    emit(state, val % 256)
    let v1 = val / 256
    emit(state, v1 % 256)
    let v2 = v1 / 256
    emit(state, v2 % 256)
    let v3 = v2 / 256
    emit(state, v3 % 256)
    emit(state, 0)
    emit(state, 0)
    emit(state, 0)
    emit(state, 0)
    return 0
}

fn add_string_data(state, str_ptr) {
    let data_buf = state[7]
    let data_pos = state[8]
    let offset = data_pos
    
    let i = 0
    let c = getbyte(str_ptr, i)
    while c > 0 {
        setbyte(data_buf, data_pos, c)
        data_pos = data_pos + 1
        i = i + 1
        c = getbyte(str_ptr, i)
    }
    setbyte(data_buf, data_pos, 0)
    data_pos = data_pos + 1
    
    state[8] = data_pos
    return offset
}

// ============================================================================
// SECTION 4: PE BUILDER
// ============================================================================

fn put_byte(state, b) {
    let exe_buf = state[5]
    let exe_pos = state[6]
    setbyte(exe_buf, exe_pos, b)
    state[6] = exe_pos + 1
    return 0
}

fn put_word(state, w) {
    put_byte(state, w % 256)
    let w1 = w / 256
    put_byte(state, w1 % 256)
    return 0
}

fn put_dword(state, d) {
    put_byte(state, d % 256)
    let d1 = d / 256
    put_byte(state, d1 % 256)
    let d2 = d1 / 256
    put_byte(state, d2 % 256)
    let d3 = d2 / 256
    put_byte(state, d3 % 256)
    return 0
}

fn put_qword(state, q) {
    put_dword(state, q)
    put_dword(state, 0)
    return 0
}

fn put_zeros(state, count) {
    let i = 0
    while i < count {
        put_byte(state, 0)
        i = i + 1
    }
    return 0
}

fn emit_pe_header(state, code_size) {
    put_byte(state, 77)
    put_byte(state, 90)
    put_zeros(state, 58)
    put_dword(state, 64)

    put_byte(state, 80)
    put_byte(state, 69)
    put_word(state, 0)

    put_word(state, 34404)
    put_word(state, 2)
    put_dword(state, 0)
    put_dword(state, 0)
    put_dword(state, 0)
    put_word(state, 240)
    put_word(state, 34)

    put_word(state, 523)
    put_byte(state, 1)
    put_byte(state, 0)
    put_dword(state, 512)
    put_dword(state, 0)
    put_dword(state, 0)
    put_dword(state, 4096)
    put_dword(state, 4096)

    put_qword(state, 4194304)
    put_dword(state, 4096)
    put_dword(state, 512)
    put_word(state, 6)
    put_word(state, 0)
    put_word(state, 0)
    put_word(state, 0)
    put_word(state, 6)
    put_word(state, 0)
    put_dword(state, 0)
    put_dword(state, 12288)
    put_dword(state, 512)
    put_dword(state, 0)
    put_word(state, 3)
    put_word(state, 0)
    put_qword(state, 1048576)
    put_qword(state, 4096)
    put_qword(state, 1048576)
    put_qword(state, 4096)
    put_dword(state, 0)
    put_dword(state, 16)

    put_dword(state, 0)
    put_dword(state, 0)
    put_dword(state, 8192)
    put_dword(state, 40)
    put_zeros(state, 80)
    put_dword(state, 8232)
    put_dword(state, 72)
    put_zeros(state, 24)

    put_byte(state, 46)
    put_byte(state, 116)
    put_byte(state, 101)
    put_byte(state, 120)
    put_byte(state, 116)
    put_zeros(state, 3)
    put_dword(state, code_size)
    put_dword(state, 4096)
    put_dword(state, 512)
    put_dword(state, 512)
    put_zeros(state, 12)
    put_dword(state, 1610612768)

    put_byte(state, 46)
    put_byte(state, 105)
    put_byte(state, 100)
    put_byte(state, 97)
    put_byte(state, 116)
    put_byte(state, 97)
    put_zeros(state, 2)
    put_dword(state, 512)
    put_dword(state, 8192)
    put_dword(state, 512)
    put_dword(state, 1024)
    put_zeros(state, 12)
    put_dword(state, 1073741888)

    let exe_pos = state[6]
    while exe_pos < 512 {
        put_byte(state, 0)
        exe_pos = state[6]
    }
    return 0
}

fn emit_import_table(state) {
    let IDATA_RVA = 8192

    put_dword(state, IDATA_RVA + 40)
    put_dword(state, 0)
    put_dword(state, 0)
    put_dword(state, IDATA_RVA + 112)
    put_dword(state, IDATA_RVA + 40)

    put_zeros(state, 20)

    let hint_base = IDATA_RVA + 126
    put_qword(state, hint_base)
    put_qword(state, hint_base + 14)
    put_qword(state, hint_base + 30)
    put_qword(state, hint_base + 44)
    put_qword(state, hint_base + 56)
    put_qword(state, hint_base + 68)
    put_qword(state, hint_base + 82)
    put_qword(state, hint_base + 96)
    put_qword(state, 0)

    // KERNEL32.DLL
    put_byte(state, 75)
    put_byte(state, 69)
    put_byte(state, 82)
    put_byte(state, 78)
    put_byte(state, 69)
    put_byte(state, 76)
    put_byte(state, 51)
    put_byte(state, 50)
    put_byte(state, 46)
    put_byte(state, 68)
    put_byte(state, 76)
    put_byte(state, 76)
    put_byte(state, 0)
    put_byte(state, 0)

    // ExitProcess
    put_word(state, 0)
    put_byte(state, 69)
    put_byte(state, 120)
    put_byte(state, 105)
    put_byte(state, 116)
    put_byte(state, 80)
    put_byte(state, 114)
    put_byte(state, 111)
    put_byte(state, 99)
    put_byte(state, 101)
    put_byte(state, 115)
    put_byte(state, 115)
    put_byte(state, 0)

    // VirtualAlloc
    put_word(state, 0)
    put_byte(state, 86)
    put_byte(state, 105)
    put_byte(state, 114)
    put_byte(state, 116)
    put_byte(state, 117)
    put_byte(state, 97)
    put_byte(state, 108)
    put_byte(state, 65)
    put_byte(state, 108)
    put_byte(state, 108)
    put_byte(state, 111)
    put_byte(state, 99)
    put_byte(state, 0)
    put_byte(state, 0)

    // VirtualFree
    put_word(state, 0)
    put_byte(state, 86)
    put_byte(state, 105)
    put_byte(state, 114)
    put_byte(state, 116)
    put_byte(state, 117)
    put_byte(state, 97)
    put_byte(state, 108)
    put_byte(state, 70)
    put_byte(state, 114)
    put_byte(state, 101)
    put_byte(state, 101)
    put_byte(state, 0)

    // WriteFile
    put_word(state, 0)
    put_byte(state, 87)
    put_byte(state, 114)
    put_byte(state, 105)
    put_byte(state, 116)
    put_byte(state, 101)
    put_byte(state, 70)
    put_byte(state, 105)
    put_byte(state, 108)
    put_byte(state, 101)
    put_byte(state, 0)

    // ReadFile
    put_word(state, 0)
    put_byte(state, 82)
    put_byte(state, 101)
    put_byte(state, 97)
    put_byte(state, 100)
    put_byte(state, 70)
    put_byte(state, 105)
    put_byte(state, 108)
    put_byte(state, 101)
    put_byte(state, 0)
    put_byte(state, 0)

    // CreateFileA
    put_word(state, 0)
    put_byte(state, 67)
    put_byte(state, 114)
    put_byte(state, 101)
    put_byte(state, 97)
    put_byte(state, 116)
    put_byte(state, 101)
    put_byte(state, 70)
    put_byte(state, 105)
    put_byte(state, 108)
    put_byte(state, 101)
    put_byte(state, 65)
    put_byte(state, 0)

    // CloseHandle
    put_word(state, 0)
    put_byte(state, 67)
    put_byte(state, 108)
    put_byte(state, 111)
    put_byte(state, 115)
    put_byte(state, 101)
    put_byte(state, 72)
    put_byte(state, 97)
    put_byte(state, 110)
    put_byte(state, 100)
    put_byte(state, 108)
    put_byte(state, 101)
    put_byte(state, 0)

    // GetStdHandle
    put_word(state, 0)
    put_byte(state, 71)
    put_byte(state, 101)
    put_byte(state, 116)
    put_byte(state, 83)
    put_byte(state, 116)
    put_byte(state, 100)
    put_byte(state, 72)
    put_byte(state, 97)
    put_byte(state, 110)
    put_byte(state, 100)
    put_byte(state, 108)
    put_byte(state, 101)
    put_byte(state, 0)
    put_byte(state, 0)

    let exe_pos = state[6]
    while exe_pos < 1536 {
        put_byte(state, 0)
        exe_pos = state[6]
    }
    return 0
}

// ============================================================================
// SECTION 5: LEXER
// ============================================================================

fn add_token(state, ttype, text) {
    let tokens_buf = state[0]
    let count = state[1]
    
    let offset = count * 16
    setbyte(tokens_buf, offset, ttype)
    
    let text_off = offset + 1
    setbyte(tokens_buf, text_off, text % 256)
    let t1 = text / 256
    setbyte(tokens_buf, text_off + 1, t1 % 256)
    let t2 = t1 / 256
    setbyte(tokens_buf, text_off + 2, t2 % 256)
    let t3 = t2 / 256
    setbyte(tokens_buf, text_off + 3, t3 % 256)
    let t4 = t3 / 256
    setbyte(tokens_buf, text_off + 4, t4 % 256)
    let t5 = t4 / 256
    setbyte(tokens_buf, text_off + 5, t5 % 256)
    let t6 = t5 / 256
    setbyte(tokens_buf, text_off + 6, t6 % 256)
    let t7 = t6 / 256
    setbyte(tokens_buf, text_off + 7, t7 % 256)
    
    state[1] = count + 1
    return 0
}

fn get_token_type(state, idx) {
    let tokens_buf = state[0]
    let offset = idx * 16
    return getbyte(tokens_buf, offset)
}

fn get_token_text(state, idx) {
    let tokens_buf = state[0]
    let offset = idx * 16 + 1
    
    let ptr = getbyte(tokens_buf, offset)
    ptr = ptr + getbyte(tokens_buf, offset + 1) * 256
    ptr = ptr + getbyte(tokens_buf, offset + 2) * 65536
    ptr = ptr + getbyte(tokens_buf, offset + 3) * 16777216
    return ptr
}

fn skip_whitespace(state) {
    let src = state[9]
    let pos = state[10]
    let len = state[11]
    
    while pos < len {
        let c = getbyte(src, pos)
        if c == 32 {
            pos = pos + 1
        }
        if c == 9 {
            pos = pos + 1
        }
        if c == 10 {
            pos = pos + 1
        }
        if c == 13 {
            pos = pos + 1
        }
        if c != 32 {
            if c != 9 {
                if c != 10 {
                    if c != 13 {
                        state[10] = pos
                        return 0
                    }
                }
            }
        }
    }
    state[10] = pos
    return 0
}

fn skip_comment(state) {
    let src = state[9]
    let pos = state[10]
    let len = state[11]
    
    if pos + 1 < len {
        let c1 = getbyte(src, pos)
        let c2 = getbyte(src, pos + 1)
        if c1 == 47 {
            if c2 == 47 {
                while pos < len {
                    let c = getbyte(src, pos)
                    if c == 10 {
                        state[10] = pos + 1
                        return 1
                    }
                    pos = pos + 1
                }
                state[10] = pos
                return 1
            }
        }
    }
    return 0
}

fn tokenize(state) {
    let src = state[9]
    let len = state[11]
    
    while state[10] < len {
        skip_whitespace(state)
        if state[10] >= len {
            return 0
        }
        
        let skipped = skip_comment(state)
        if skipped == 0 {
            let pos = state[10]
            let c = getbyte(src, pos)
            
            if is_alpha(c) == 1 {
                let start = pos
                while is_alnum(getbyte(src, pos)) == 1 {
                    pos = pos + 1
                }
                let ident_len = pos - start
                let ident = alloc(ident_len + 1)
                let ii = 0
                while ii < ident_len {
                    setbyte(ident, ii, getbyte(src, start + ii))
                    ii = ii + 1
                }
                setbyte(ident, ident_len, 0)
                state[10] = pos
                
                let is_kw = 0
                if str_eq(ident, "fn") == 1 {
                    is_kw = 1
                }
                if str_eq(ident, "let") == 1 {
                    is_kw = 1
                }
                if str_eq(ident, "if") == 1 {
                    is_kw = 1
                }
                if str_eq(ident, "while") == 1 {
                    is_kw = 1
                }
                if str_eq(ident, "return") == 1 {
                    is_kw = 1
                }
                
                if is_kw == 1 {
                    add_token(state, 5, ident)
                }
                if is_kw == 0 {
                    add_token(state, 1, ident)
                }
            }
            
            if is_digit(c) == 1 {
                let start = pos
                let value = 0
                while is_digit(getbyte(src, pos)) == 1 {
                    value = value * 10 + getbyte(src, pos) - 48
                    pos = pos + 1
                }
                state[10] = pos
                
                let num_str = alloc(16)
                let ni = 0
                let nv = value
                if nv == 0 {
                    setbyte(num_str, 0, 48)
                    ni = 1
                }
                while nv > 0 {
                    setbyte(num_str, ni, 48 + nv % 10)
                    nv = nv / 10
                    ni = ni + 1
                }
                setbyte(num_str, ni, 0)
                let nj = 0
                let nk = ni - 1
                while nj < nk {
                    let tmp = getbyte(num_str, nj)
                    setbyte(num_str, nj, getbyte(num_str, nk))
                    setbyte(num_str, nk, tmp)
                    nj = nj + 1
                    nk = nk - 1
                }
                add_token(state, 2, num_str)
            }
            
            if c == 45 {
                let next = getbyte(src, pos + 1)
                if is_digit(next) == 1 {
                    pos = pos + 1
                    let value = 0
                    while is_digit(getbyte(src, pos)) == 1 {
                        value = value * 10 + getbyte(src, pos) - 48
                        pos = pos + 1
                    }
                    state[10] = pos
                    
                    let num_str = alloc(16)
                    setbyte(num_str, 0, 45)
                    let ni = 1
                    let nv = value
                    if nv == 0 {
                        setbyte(num_str, 1, 48)
                        ni = 2
                    }
                    while nv > 0 {
                        setbyte(num_str, ni, 48 + nv % 10)
                        nv = nv / 10
                        ni = ni + 1
                    }
                    setbyte(num_str, ni, 0)
                    let nj = 1
                    let nk = ni - 1
                    while nj < nk {
                        let tmp = getbyte(num_str, nj)
                        setbyte(num_str, nj, getbyte(num_str, nk))
                        setbyte(num_str, nk, tmp)
                        nj = nj + 1
                        nk = nk - 1
                    }
                    add_token(state, 2, num_str)
                }
                if is_digit(next) == 0 {
                    let op = alloc(2)
                    setbyte(op, 0, 45)
                    setbyte(op, 1, 0)
                    add_token(state, 4, op)
                    state[10] = pos + 1
                }
            }
            
            if c == 34 {
                pos = pos + 1
                let start = pos
                while getbyte(src, pos) != 34 {
                    pos = pos + 1
                }
                let str_len = pos - start
                let str_val = alloc(str_len + 1)
                let si = 0
                while si < str_len {
                    setbyte(str_val, si, getbyte(src, start + si))
                    si = si + 1
                }
                setbyte(str_val, str_len, 0)
                state[10] = pos + 1
                add_token(state, 3, str_val)
            }
            
            if c == 40 {
                let op = alloc(2)
                setbyte(op, 0, 40)
                setbyte(op, 1, 0)
                add_token(state, 4, op)
                state[10] = pos + 1
            }
            if c == 41 {
                let op = alloc(2)
                setbyte(op, 0, 41)
                setbyte(op, 1, 0)
                add_token(state, 4, op)
                state[10] = pos + 1
            }
            if c == 123 {
                let op = alloc(2)
                setbyte(op, 0, 123)
                setbyte(op, 1, 0)
                add_token(state, 4, op)
                state[10] = pos + 1
            }
            if c == 125 {
                let op = alloc(2)
                setbyte(op, 0, 125)
                setbyte(op, 1, 0)
                add_token(state, 4, op)
                state[10] = pos + 1
            }
            if c == 61 {
                let op = alloc(2)
                setbyte(op, 0, 61)
                setbyte(op, 1, 0)
                add_token(state, 4, op)
                state[10] = pos + 1
            }
            if c == 44 {
                let op = alloc(2)
                setbyte(op, 0, 44)
                setbyte(op, 1, 0)
                add_token(state, 4, op)
                state[10] = pos + 1
            }
        }
    }
    return 0
}

// ============================================================================
// SECTION 6: PARSER & CODEGEN
// ============================================================================

fn current_token_type(state) {
    let pos = state[2]
    return get_token_type(state, pos)
}

fn current_token_text(state) {
    let pos = state[2]
    return get_token_text(state, pos)
}

fn advance(state) {
    state[2] = state[2] + 1
    return 0
}

fn expect_text(state, expected) {
    let text = current_token_text(state)
    if str_eq(text, expected) == 1 {
        advance(state)
        return 1
    }
    return 0
}

fn lookup_var(state, name) {
    let count = state[28]
    let i = 0
    while i < count {
        let var_name = state[12 + i]
        if str_eq(var_name, name) == 1 {
            return state[20 + i]
        }
        i = i + 1
    }
    return 0 - 1
}

fn add_var(state, name) {
    let count = state[28]
    let offset = state[29] + 8
    state[29] = offset
    
    state[12 + count] = name
    state[20 + count] = offset
    state[28] = count + 1
    return offset
}

fn parse_number(state) {
    let text = current_token_text(state)
    advance(state)
    
    let val = 0
    let neg = 0
    let i = 0
    if getbyte(text, 0) == 45 {
        neg = 1
        i = 1
    }
    while getbyte(text, i) > 0 {
        val = val * 10 + getbyte(text, i) - 48
        i = i + 1
    }
    if neg == 1 {
        val = 0 - val
    }
    
    if val >= 0 {
        if val < 2147483648 {
            emit(state, 184)
            emit_dword(state, val)
        }
    }
    if val < 0 {
        emit(state, 184)
        emit_dword(state, val)
    }
    return 0
}

fn parse_call(state, name) {
    expect_text(state, "(")
    
    // exit(code)
    if str_eq(name, "exit") == 1 {
        parse_expr(state)
        expect_text(state, ")")
        
        emit(state, 137)
        emit(state, 193)
        emit_iat_call(state, 0)
        return 0
    }
    
    // getstd(n)
    if str_eq(name, "getstd") == 1 {
        parse_expr(state)
        expect_text(state, ")")
        
        emit(state, 137)
        emit(state, 193)
        emit_iat_call(state, 7)
        return 0
    }
    
    // write(handle, buf, len)
    if str_eq(name, "write") == 1 {
        parse_expr(state)
        emit(state, 80)
        expect_text(state, ",")
        
        parse_expr(state)
        emit(state, 80)
        expect_text(state, ",")
        
        parse_expr(state)
        emit(state, 73)
        emit(state, 137)
        emit(state, 192)
        
        expect_text(state, ")")
        
        emit(state, 90)
        emit(state, 89)
        
        emit(state, 77)
        emit(state, 49)
        emit(state, 201)
        
        emit(state, 72)
        emit(state, 199)
        emit(state, 68)
        emit(state, 36)
        emit(state, 32)
        emit(state, 0)
        emit(state, 0)
        emit(state, 0)
        emit(state, 0)
        
        emit_iat_call(state, 3)
        return 0
    }
    
    while str_eq(current_token_text(state), ")") == 0 {
        advance(state)
    }
    expect_text(state, ")")
    return 0
}

fn parse_ident(state) {
    let name = current_token_text(state)
    advance(state)
    
    let next_text = current_token_text(state)
    if str_eq(next_text, "(") == 1 {
        return parse_call(state, name)
    }
    
    let offset = lookup_var(state, name)
    if offset > 0 {
        emit(state, 72)
        emit(state, 139)
        emit(state, 69)
        let neg_off = 256 - offset
        emit(state, neg_off)
    }
    return 0
}

fn parse_expr(state) {
    let ttype = current_token_type(state)
    
    if ttype == 2 {
        parse_number(state)
        return 0
    }
    
    if ttype == 3 {
        let text = current_token_text(state)
        advance(state)
        
        let offset = add_string_data(state, text)
        let str_va = 4198656 + offset
        emit_mov_rax_imm64(state, str_va)
        return 0
    }
    
    if ttype == 1 {
        parse_ident(state)
        return 0
    }
    
    return 0
}

fn parse_let(state) {
    expect_text(state, "let")
    
    let name = current_token_text(state)
    advance(state)
    
    expect_text(state, "=")
    
    parse_expr(state)
    
    let offset = add_var(state, name)
    
    emit(state, 72)
    emit(state, 137)
    emit(state, 69)
    let neg_off = 256 - offset
    emit(state, neg_off)
    
    return 0
}

fn parse_statement(state) {
    let text = current_token_text(state)
    
    if str_eq(text, "let") == 1 {
        parse_let(state)
        return 0
    }
    
    if str_eq(text, "return") == 1 {
        advance(state)
        parse_expr(state)
        return 0
    }
    
    parse_expr(state)
    return 0
}

fn parse_function(state) {
    expect_text(state, "fn")
    
    let name = current_token_text(state)
    advance(state)
    
    expect_text(state, "{")
    
    state[28] = 0
    state[29] = 0
    
    emit(state, 72)
    emit(state, 131)
    emit(state, 236)
    emit(state, 56)
    
    while str_eq(current_token_text(state), "}") == 0 {
        parse_statement(state)
    }
    
    expect_text(state, "}")
    return 0
}

fn parse_program(state) {
    while state[2] < state[1] {
        let text = current_token_text(state)
        if str_eq(text, "fn") == 1 {
            parse_function(state)
        }
        if str_eq(text, "fn") == 0 {
            advance(state)
        }
    }
    return 0
}

// ============================================================================
// SECTION 7: MAIN COMPILER
// ============================================================================

fn main() {
    let state = alloc(256)
    init_compiler(state)
    
    // Open "in.syn"
    let fname = alloc(8)
    setbyte(fname, 0, 105)
    setbyte(fname, 1, 110)
    setbyte(fname, 2, 46)
    setbyte(fname, 3, 115)
    setbyte(fname, 4, 121)
    setbyte(fname, 5, 110)
    setbyte(fname, 6, 0)
    
    let fd = open(fname, 0)
    
    let source = alloc(16384)
    let bytes_read = read(fd, source, 16384)
    close(fd)
    
    state[9] = source
    state[10] = 0
    state[11] = str_len(source)
    
    // Tokenize
    tokenize(state)
    
    // Parse and generate code
    parse_program(state)
    
    let code_size = state[4]
    let data_size = state[8]
    
    // Build PE
    emit_pe_header(state, 512)
    
    // Copy code to exe_buf at offset 512
    let code_buf = state[3]
    let exe_buf = state[5]
    let ci = 0
    while ci < code_size {
        setbyte(exe_buf, 512 + ci, getbyte(code_buf, ci))
        ci = ci + 1
    }
    
    // Copy data to exe_buf at offset 512 + 256
    let data_buf = state[7]
    let di = 0
    while di < data_size {
        setbyte(exe_buf, 512 + 256 + di, getbyte(data_buf, di))
        di = di + 1
    }
    
    // Import table
    state[6] = 1024
    emit_import_table(state)
    
    // Write "out.exe"
    let outname = alloc(8)
    setbyte(outname, 0, 111)
    setbyte(outname, 1, 117)
    setbyte(outname, 2, 116)
    setbyte(outname, 3, 46)
    setbyte(outname, 4, 101)
    setbyte(outname, 5, 120)
    setbyte(outname, 6, 101)
    setbyte(outname, 7, 0)
    
    let out_fd = open(outname, 1)
    let exe_size = state[6]
    write(out_fd, exe_buf, exe_size)
    close(out_fd)
    
    return 0
}
