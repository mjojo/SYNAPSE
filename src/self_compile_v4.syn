// ============================================================
// SYNAPSE SELF-COMPILE V4 (Phase 42 - Stack Machine CodeGen)
// Recursive Parser + Recursive Code Generator
// ============================================================

// --- CONSTANTS ---
let TOK_NUM = 1
let TOK_PLUS = 2
let TOK_MUL = 3
let TOK_EOF = 0

let NODE_NUM = 1
let NODE_ADD = 2
let NODE_MUL = 3

// --- CONTEXT MANAGEMENT ---
// ctx[0] = Token Types Array
// ctx[1] = Token Vals Array
// ctx[2] = Token Count
// ctx[3] = Parse Cursor
// ctx[4] = AST Arena
// ctx[5] = Code Buffer
// ctx[6] = Code Cursor

fn ctx_new() {
    let ctx = alloc(10)
    ctx[0] = alloc(100)
    ctx[1] = alloc(100)
    ctx[2] = 0
    ctx[3] = 0
    ctx[4] = alloc(500)
    ctx[5] = alloc_bytes(1024)
    ctx[6] = 0
    let ar = ctx[4]
    ar[0] = 4
    return ctx
}

fn emit_tok(ctx, t, v) {
    let n = ctx[2]
    let ta = ctx[0]
    ta[n] = t
    let va = ctx[1]
    va[n] = v
    ctx[2] = n + 1
}

fn peek(ctx) {
    let c = ctx[3]
    let ta = ctx[0]
    return ta[c]
}

fn peek_val(ctx) {
    let c = ctx[3]
    let va = ctx[1]
    return va[c]
}

fn advance(ctx) {
    let c = ctx[3]
    ctx[3] = c + 1
}

// --- AST ---
fn ast_new(ctx, t, v) {
    let ar = ctx[4]
    let i = ar[0]
    ar[i] = t
    let p1 = i + 1
    ar[p1] = v
    let p2 = i + 2
    ar[p2] = 0
    let p3 = i + 3
    ar[p3] = 0
    ar[0] = i + 4
    return i
}

fn ast_link(ctx, p, l, r) {
    let ar = ctx[4]
    let pl = p + 2
    ar[pl] = l
    let pr = p + 3
    ar[pr] = r
}

// --- PARSER (Recursive Descent with Precedence) ---
fn parse_factor(ctx) {
    let t = peek(ctx)
    if (t == TOK_NUM) {
        let v = peek_val(ctx)
        advance(ctx)
        return ast_new(ctx, NODE_NUM, v)
    }
    return 0
}

fn parse_term(ctx) {
    let left = parse_factor(ctx)
    let t = peek(ctx)
    while (t == TOK_MUL) {
        advance(ctx)
        let right = parse_factor(ctx)
        let op = ast_new(ctx, NODE_MUL, 0)
        ast_link(ctx, op, left, right)
        left = op
        t = peek(ctx)
    }
    return left
}

fn parse_expr(ctx) {
    let left = parse_term(ctx)
    let t = peek(ctx)
    while (t == TOK_PLUS) {
        advance(ctx)
        let right = parse_term(ctx)
        let op = ast_new(ctx, NODE_ADD, 0)
        ast_link(ctx, op, left, right)
        left = op
        t = peek(ctx)
    }
    return left
}

// --- CODE GENERATION (Stack Machine) ---
fn emit8(ctx, b) {
    let buf = ctx[5]
    let ci = ctx[6]
    set_byte(buf, ci, b)
    ctx[6] = ci + 1
}

fn emit64(ctx, val) {
    emit8(ctx, val)
    let v1 = val / 256
    emit8(ctx, 0)
    emit8(ctx, 0)
    emit8(ctx, 0)
    emit8(ctx, 0)
    emit8(ctx, 0)
    emit8(ctx, 0)
    emit8(ctx, 0)
}

fn gen(ctx, node) {
    if (node == 0) { return 0 }
    
    let ar = ctx[4]
    let type = ar[node]
    
    // NUMBER: MOV RAX, val
    if (type == NODE_NUM) {
        let val_idx = node + 1
        let val = ar[val_idx]
        emit8(ctx, 72)   // 48 REX.W
        emit8(ctx, 184)  // B8 MOV RAX
        emit64(ctx, val)
        return 0
    }
    
    // BINARY OP
    let left_idx = node + 2
    let left = ar[left_idx]
    let right_idx = node + 3
    let right = ar[right_idx]
    
    // Gen Left -> Result in RAX
    gen(ctx, left)
    emit8(ctx, 80)   // 50 PUSH RAX
    
    // Gen Right -> Result in RAX
    gen(ctx, right)
    
    // MOV RCX, RAX (save Right)
    emit8(ctx, 72)   // 48
    emit8(ctx, 137)  // 89
    emit8(ctx, 193)  // C1
    
    // POP RAX (restore Left)
    emit8(ctx, 88)   // 58
    
    // Apply operator
    if (type == NODE_ADD) {
        // ADD RAX, RCX (48 01 C8)
        emit8(ctx, 72)
        emit8(ctx, 1)
        emit8(ctx, 200)
    }
    
    if (type == NODE_MUL) {
        // IMUL RAX, RCX (48 0F AF C1)
        emit8(ctx, 72)
        emit8(ctx, 15)
        emit8(ctx, 175)
        emit8(ctx, 193)
    }
    
    return 0
}

fn dump_code(ctx) {
    let buf = ctx[5]
    let len = ctx[6]
    let i = 0
    while (i < len) {
        print(get_byte(buf, i))
        i = i + 1
    }
}

// --- MAIN ---
fn main() {
    print(100000)
    let ctx = ctx_new()
    
    // Lex: "10 + 2 * 5"
    emit_tok(ctx, TOK_NUM, 10)
    emit_tok(ctx, TOK_PLUS, 0)
    emit_tok(ctx, TOK_NUM, 2)
    emit_tok(ctx, TOK_MUL, 0)
    emit_tok(ctx, TOK_NUM, 5)
    emit_tok(ctx, TOK_EOF, 0)
    print(200000)
    
    // Parse with precedence: 10 + (2 * 5)
    let root = parse_expr(ctx)
    print(300000)
    
    // Generate code
    gen(ctx, root)
    print(400000)
    
    // Dump machine code bytes
    dump_code(ctx)
    print(999999)
}
