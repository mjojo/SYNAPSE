// ============================================================
// SYNAPSE SELF-HOSTED COMPILER V2 (Phase 32)
// Lexer + Parser Integration - The Grand Unification
// ============================================================

// --- AST ENGINE ---

fn ast_new(type, val) {
    let node = alloc(4)
    node[0] = type
    node[1] = val
    node[2] = 0
    node[3] = 0
    return node
}

// --- LEXER HELPERS ---

fn is_digit(c) {
    let result = 0
    if (c > 47) {
        if (c < 58) {
            result = 1
        }
    }
    return result
}

fn is_alpha(c) {
    let result = 0
    if (c > 96) {
        if (c < 123) {
            result = 1
        }
    }
    return result
}

// --- THE LEXER ---

fn lex(src, src_len, types, vals) {
    let i = 0
    let tok_count = 0
    
    while (i < src_len) {
        let c = get_byte(src, i)
        let handled = 0
        
        // Skip whitespace (space=32, newline=10, tab=9)
        if (c == 32) {
            i = i + 1
            handled = 1
        }
        if (c == 10) {
            i = i + 1
            handled = 1
        }
        if (c == 9) {
            i = i + 1
            handled = 1
        }
        
        // Check 'fn' (f=102, n=110)
        if (handled == 0) {
            if (c == 102) {
                let n = get_byte(src, i + 1)
                if (n == 110) {
                    types[tok_count] = 1
                    vals[tok_count] = 0
                    tok_count = tok_count + 1
                    i = i + 2
                    handled = 1
                }
            }
        }
        
        // Check 'let' (l=108, e=101, t=116)
        if (handled == 0) {
            if (c == 108) {
                let e = get_byte(src, i + 1)
                if (e == 101) {
                    let t = get_byte(src, i + 2)
                    if (t == 116) {
                        types[tok_count] = 6
                        vals[tok_count] = 0
                        tok_count = tok_count + 1
                        i = i + 3
                        handled = 1
                    }
                }
            }
        }
        
        // Check 'return' (r=114)
        if (handled == 0) {
            if (c == 114) {
                let e = get_byte(src, i + 1)
                if (e == 101) {
                    // Skip 'return' (6 chars)
                    types[tok_count] = 8
                    vals[tok_count] = 0
                    tok_count = tok_count + 1
                    i = i + 6
                    handled = 1
                }
            }
        }
        
        // Check '{' (123)
        if (handled == 0) {
            if (c == 123) {
                types[tok_count] = 4
                vals[tok_count] = 0
                tok_count = tok_count + 1
                i = i + 1
                handled = 1
            }
        }
        
        // Check '}' (125)
        if (handled == 0) {
            if (c == 125) {
                types[tok_count] = 5
                vals[tok_count] = 0
                tok_count = tok_count + 1
                i = i + 1
                handled = 1
            }
        }
        
        // Check '=' (61)
        if (handled == 0) {
            if (c == 61) {
                types[tok_count] = 7
                vals[tok_count] = 0
                tok_count = tok_count + 1
                i = i + 1
                handled = 1
            }
        }
        
        // Check number
        if (handled == 0) {
            let d = is_digit(c)
            if (d == 1) {
                let num = c - 48
                let next = get_byte(src, i + 1)
                let d2 = is_digit(next)
                if (d2 == 1) {
                    num = num * 10 + next - 48
                    i = i + 2
                } else {
                    i = i + 1
                }
                types[tok_count] = 3
                vals[tok_count] = num
                tok_count = tok_count + 1
                handled = 1
            }
        }
        
        // Check identifier (single letter for simplicity)
        if (handled == 0) {
            let a = is_alpha(c)
            if (a == 1) {
                types[tok_count] = 2
                vals[tok_count] = c
                tok_count = tok_count + 1
                i = i + 1
                handled = 1
            }
        }
        
        // Unknown char - skip
        if (handled == 0) {
            i = i + 1
        }
    }
    
    return tok_count
}

// --- PARSER ---

fn parse_all(types, vals, tok_count) {
    // Parse: fn <name> { let <var> = <num> }
    // Token order: FN, ID, LBRACE, LET, ID, EQ, NUM, RBRACE
    
    // Read tokens by index
    // 0: fn (skip)
    // 1: name
    let fn_name = vals[1]
    
    // 2: { (skip)
    // 3: let (skip)
    // 4: var name
    let var_name = vals[4]
    
    // 5: = (skip)
    // 6: number
    let num_val = vals[6]
    
    // 7: } (skip)
    
    // Build AST bottom-up
    // NODE_NUM = 5
    let num_node = ast_new(5, num_val)
    
    // NODE_LET = 4
    let let_node = ast_new(4, var_name)
    let_node[2] = num_node
    
    // NODE_BLOCK = 3
    let block_node = ast_new(3, 0)
    block_node[2] = let_node
    
    // NODE_FN = 2
    let fn_node = ast_new(2, fn_name)
    fn_node[2] = block_node
    
    return fn_node
}

// --- ITERATIVE WALKER ---

fn walk_tree(root) {
    let stack_n = alloc(64)
    let stack_d = alloc(64)
    let sp = 0
    
    stack_n[0] = root
    stack_d[0] = 0
    sp = 1
    
    while (sp > 0) {
        sp = sp - 1
        let node = stack_n[sp]
        let depth = stack_d[sp]
        
        let indent = depth * 1111
        let t = node[0]
        let v = node[1]
        print(indent)
        print(t)
        print(v)
        
        let sib = node[3]
        if (sib > 0) {
            stack_n[sp] = sib
            stack_d[sp] = depth
            sp = sp + 1
        }
        
        let child = node[2]
        if (child > 0) {
            stack_n[sp] = child
            stack_d[sp] = depth + 1
            sp = sp + 1
        }
    }
    
    return 0
}

// --- MAIN ---

fn main() {
    print(100000)
    
    // === 1. CREATE SOURCE CODE IN MEMORY ===
    // Code: "fn m { let x = 55 }"
    let src = alloc_bytes(32)
    
    // fn m { let x = 55 }
    set_byte(src, 0, 102)   // f
    set_byte(src, 1, 110)   // n
    set_byte(src, 2, 32)    // space
    set_byte(src, 3, 109)   // m
    set_byte(src, 4, 32)    // space
    set_byte(src, 5, 123)   // {
    set_byte(src, 6, 32)    // space
    set_byte(src, 7, 108)   // l
    set_byte(src, 8, 101)   // e
    set_byte(src, 9, 116)   // t
    set_byte(src, 10, 32)   // space
    set_byte(src, 11, 120)  // x
    set_byte(src, 12, 32)   // space
    set_byte(src, 13, 61)   // =
    set_byte(src, 14, 32)   // space
    set_byte(src, 15, 53)   // 5
    set_byte(src, 16, 53)   // 5
    set_byte(src, 17, 32)   // space
    set_byte(src, 18, 125)  // }
    
    let src_len = 19
    
    print(200000)
    
    // === 2. ALLOCATE TOKEN BUFFERS ===
    let types = alloc(32)
    let vals = alloc(32)
    
    // === 3. RUN LEXER ===
    let tok_count = lex(src, src_len, types, vals)
    
    print(tok_count)
    
    // Debug: print all tokens
    print(250000)
    let i = 0
    while (i < tok_count) {
        let t = types[i]
        let v = vals[i]
        print(t)
        print(v)
        i = i + 1
    }
    
    print(300000)
    
    // === 4. RUN PARSER ===
    let root = parse_all(types, vals, tok_count)
    
    print(400000)
    
    // === 5. WALK AST ===
    walk_tree(root)
    
    print(500000)
    
    return 0
}
