// SYNAPSE SINGULARITY - HARDCODED BOOTSTRAP
// This reads in.syn but generates the same fixed Hello World code
// Purpose: Prove that the JIT-compiled compiler can read files and write EXE

fn str_len(s) {
    let i = 0
    while getbyte(s, i) > 0 {
        i = i + 1
    }
    return i
}

fn io_print(s) {
    let len = str_len(s)
    let h = getstd(-11)
    write(h, s, len)
    return 0
}

fn print_nl() {
    let nl = alloc(2)
    setbyte(nl, 0, 10)
    setbyte(nl, 1, 0)
    io_print(nl)
    return 0
}

fn io_println(s) {
    io_print(s)
    print_nl()
    return 0
}

// --- PE BUILDER ---
fn init_state(state) {
    state[5] = alloc(8192)
    state[6] = 0
    return 0
}

fn put_byte(state, b) {
    let exe_buf = state[5]
    let exe_pos = state[6]
    setbyte(exe_buf, exe_pos, b)
    state[6] = exe_pos + 1
    return 0
}

fn put_word(state, w) {
    put_byte(state, w % 256)
    let w1 = w / 256
    put_byte(state, w1 % 256)
    return 0
}

fn put_dword(state, d) {
    put_byte(state, d % 256)
    let d1 = d / 256
    put_byte(state, d1 % 256)
    let d2 = d1 / 256
    put_byte(state, d2 % 256)
    let d3 = d2 / 256
    put_byte(state, d3 % 256)
    return 0
}

fn put_qword(state, q) {
    put_dword(state, q)
    put_dword(state, 0)
    return 0
}

fn put_zeros(state, count) {
    let i = 0
    while i < count {
        put_byte(state, 0)
        i = i + 1
    }
    return 0
}

fn emit_pe_header(state) {
    put_byte(state, 77)
    put_byte(state, 90)
    put_zeros(state, 58)
    put_dword(state, 64)

    put_byte(state, 80)
    put_byte(state, 69)
    put_word(state, 0)

    put_word(state, 34404)
    put_word(state, 2)
    put_dword(state, 0)
    put_dword(state, 0)
    put_dword(state, 0)
    put_word(state, 240)
    put_word(state, 34)

    put_word(state, 523)
    put_byte(state, 1)
    put_byte(state, 0)
    put_dword(state, 512)
    put_dword(state, 0)
    put_dword(state, 0)
    put_dword(state, 4096)
    put_dword(state, 4096)

    put_qword(state, 4194304)
    put_dword(state, 4096)
    put_dword(state, 512)
    put_word(state, 6)
    put_word(state, 0)
    put_word(state, 0)
    put_word(state, 0)
    put_word(state, 6)
    put_word(state, 0)
    put_dword(state, 0)
    put_dword(state, 12288)
    put_dword(state, 512)
    put_dword(state, 0)
    put_word(state, 3)
    put_word(state, 0)
    put_qword(state, 1048576)
    put_qword(state, 4096)
    put_qword(state, 1048576)
    put_qword(state, 4096)
    put_dword(state, 0)
    put_dword(state, 16)

    // Data Directories:
    // Entry 0: Export (0, 0)
    put_dword(state, 0)
    put_dword(state, 0)
    // Entry 1: Import (0x2000, 40)
    put_dword(state, 8192)
    put_dword(state, 40)
    // Entries 2-11: zeros
    put_zeros(state, 80)
    // Entry 12: IAT (0x2028, 80) - 9 entries * 8 + 8 null = 80 bytes
    put_dword(state, 8232)
    put_dword(state, 80)
    // Entries 13-15: zeros
    put_zeros(state, 24)

    put_byte(state, 46)
    put_byte(state, 116)
    put_byte(state, 101)
    put_byte(state, 120)
    put_byte(state, 116)
    put_zeros(state, 3)
    put_dword(state, 512)
    put_dword(state, 4096)
    put_dword(state, 512)
    put_dword(state, 512)
    put_zeros(state, 12)
    put_dword(state, 1610612768)

    put_byte(state, 46)
    put_byte(state, 105)
    put_byte(state, 100)
    put_byte(state, 97)
    put_byte(state, 116)
    put_byte(state, 97)
    put_zeros(state, 2)
    put_dword(state, 512)
    put_dword(state, 8192)
    put_dword(state, 512)
    put_dword(state, 1024)
    put_zeros(state, 12)
    put_dword(state, 1073741888)

    let exe_pos = state[6]
    while exe_pos < 512 {
        put_byte(state, 0)
        exe_pos = state[6]
    }
    return 0
}

fn emit_import_table(state) {
    let IDATA_RVA = 8192

    // Import Directory Table (20 bytes)
    // ILT RVA, Timestamp, Forwarder, DLL Name RVA, IAT RVA
    put_dword(state, IDATA_RVA + 40)     // ILT (same as IAT)
    put_dword(state, 0)                   // Timestamp
    put_dword(state, 0)                   // Forwarder
    put_dword(state, IDATA_RVA + 120)     // DLL Name RVA (moved! was 112)
    put_dword(state, IDATA_RVA + 40)      // IAT RVA
    put_zeros(state, 20)                  // Null terminator entry

    // IAT: 9 functions now (added GetCommandLineA)
    // 9 entries * 8 bytes = 72 bytes + 8 bytes null = 80 bytes total
    // IAT at offset 40, ends at 120
    // hint_base points to first Hint/Name entry after DLL name (14 bytes)
    // Recalculated offsets:
    //   ExitProcess:     14 bytes (2+11+1)      -> 0
    //   VirtualAlloc:    16 bytes (2+12+1+pad)  -> 14
    //   VirtualFree:     14 bytes (2+11+1)      -> 30
    //   WriteFile:       12 bytes (2+9+1)       -> 44
    //   ReadFile:        12 bytes (2+8+1+pad)   -> 56
    //   CreateFileA:     14 bytes (2+11+1)      -> 68
    //   CloseHandle:     14 bytes (2+11+1)      -> 82
    //   GetStdHandle:    16 bytes (2+12+1+pad)  -> 96
    //   GetCommandLineA: 18 bytes (2+15+1)      -> 112
    let hint_base = IDATA_RVA + 134       // 120 + 14 = 134
    put_qword(state, hint_base)           // [0] ExitProcess
    put_qword(state, hint_base + 14)      // [1] VirtualAlloc
    put_qword(state, hint_base + 30)      // [2] VirtualFree
    put_qword(state, hint_base + 44)      // [3] WriteFile
    put_qword(state, hint_base + 56)      // [4] ReadFile
    put_qword(state, hint_base + 68)      // [5] CreateFileA
    put_qword(state, hint_base + 82)      // [6] CloseHandle
    put_qword(state, hint_base + 96)      // [7] GetStdHandle
    put_qword(state, hint_base + 112)     // [8] GetCommandLineA (was 110, now 112)
    put_qword(state, 0)                   // End of IAT

    // KERNEL32.DLL
    put_byte(state, 75)
    put_byte(state, 69)
    put_byte(state, 82)
    put_byte(state, 78)
    put_byte(state, 69)
    put_byte(state, 76)
    put_byte(state, 51)
    put_byte(state, 50)
    put_byte(state, 46)
    put_byte(state, 68)
    put_byte(state, 76)
    put_byte(state, 76)
    put_byte(state, 0)
    put_byte(state, 0)

    // ExitProcess
    put_word(state, 0)
    put_byte(state, 69)
    put_byte(state, 120)
    put_byte(state, 105)
    put_byte(state, 116)
    put_byte(state, 80)
    put_byte(state, 114)
    put_byte(state, 111)
    put_byte(state, 99)
    put_byte(state, 101)
    put_byte(state, 115)
    put_byte(state, 115)
    put_byte(state, 0)

    // VirtualAlloc
    put_word(state, 0)
    put_byte(state, 86)
    put_byte(state, 105)
    put_byte(state, 114)
    put_byte(state, 116)
    put_byte(state, 117)
    put_byte(state, 97)
    put_byte(state, 108)
    put_byte(state, 65)
    put_byte(state, 108)
    put_byte(state, 108)
    put_byte(state, 111)
    put_byte(state, 99)
    put_byte(state, 0)
    put_byte(state, 0)

    // VirtualFree
    put_word(state, 0)
    put_byte(state, 86)
    put_byte(state, 105)
    put_byte(state, 114)
    put_byte(state, 116)
    put_byte(state, 117)
    put_byte(state, 97)
    put_byte(state, 108)
    put_byte(state, 70)
    put_byte(state, 114)
    put_byte(state, 101)
    put_byte(state, 101)
    put_byte(state, 0)

    // WriteFile
    put_word(state, 0)
    put_byte(state, 87)
    put_byte(state, 114)
    put_byte(state, 105)
    put_byte(state, 116)
    put_byte(state, 101)
    put_byte(state, 70)
    put_byte(state, 105)
    put_byte(state, 108)
    put_byte(state, 101)
    put_byte(state, 0)

    // ReadFile
    put_word(state, 0)
    put_byte(state, 82)
    put_byte(state, 101)
    put_byte(state, 97)
    put_byte(state, 100)
    put_byte(state, 70)
    put_byte(state, 105)
    put_byte(state, 108)
    put_byte(state, 101)
    put_byte(state, 0)
    put_byte(state, 0)

    // CreateFileA
    put_word(state, 0)
    put_byte(state, 67)
    put_byte(state, 114)
    put_byte(state, 101)
    put_byte(state, 97)
    put_byte(state, 116)
    put_byte(state, 101)
    put_byte(state, 70)
    put_byte(state, 105)
    put_byte(state, 108)
    put_byte(state, 101)
    put_byte(state, 65)
    put_byte(state, 0)

    // CloseHandle
    put_word(state, 0)
    put_byte(state, 67)
    put_byte(state, 108)
    put_byte(state, 111)
    put_byte(state, 115)
    put_byte(state, 101)
    put_byte(state, 72)
    put_byte(state, 97)
    put_byte(state, 110)
    put_byte(state, 100)
    put_byte(state, 108)
    put_byte(state, 101)
    put_byte(state, 0)

    // GetStdHandle (14 bytes: hint + "GetStdHandle\0" + pad)
    put_word(state, 0)
    put_byte(state, 71)   // G
    put_byte(state, 101)  // e
    put_byte(state, 116)  // t
    put_byte(state, 83)   // S
    put_byte(state, 116)  // t
    put_byte(state, 100)  // d
    put_byte(state, 72)   // H
    put_byte(state, 97)   // a
    put_byte(state, 110)  // n
    put_byte(state, 100)  // d
    put_byte(state, 108)  // l
    put_byte(state, 101)  // e
    put_byte(state, 0)    // null
    put_byte(state, 0)    // pad to even

    // GetCommandLineA (18 bytes: hint + "GetCommandLineA\0" + pad)
    put_word(state, 0)    // Hint
    put_byte(state, 71)   // G
    put_byte(state, 101)  // e
    put_byte(state, 116)  // t
    put_byte(state, 67)   // C
    put_byte(state, 111)  // o
    put_byte(state, 109)  // m
    put_byte(state, 109)  // m
    put_byte(state, 97)   // a
    put_byte(state, 110)  // n
    put_byte(state, 100)  // d
    put_byte(state, 76)   // L
    put_byte(state, 105)  // i
    put_byte(state, 110)  // n
    put_byte(state, 101)  // e
    put_byte(state, 65)   // A
    put_byte(state, 0)    // null

    let exe_pos = state[6]
    while exe_pos < 1536 {
        put_byte(state, 0)
        exe_pos = state[6]
    }
    return 0
}

fn save_exe(state, fname) {
    let exe_buf = state[5]
    let exe_size = state[6]
    let fd = open(fname, 1)
    write(fd, exe_buf, exe_size)
    close(fd)
    return 0
}

fn main() {
    io_println("=== SINGULARITY BOOTSTRAP v2 ===")
    io_println("Usage: synapse.exe input.syn [-o output.exe]")
    io_println("")
    
    // Parse command line (inline for reliability)
    let cmd = get_cmd_line()
    let input_file = alloc(256)
    let output_file = alloc(256)
    
    // Set default output
    setbyte(output_file, 0, 111)  // o
    setbyte(output_file, 1, 117)  // u
    setbyte(output_file, 2, 116)  // t
    setbyte(output_file, 3, 46)   // .
    setbyte(output_file, 4, 101)  // e
    setbyte(output_file, 5, 120)  // x
    setbyte(output_file, 6, 101)  // e
    setbyte(output_file, 7, 0)
    
    let pos = 0
    
    // Skip program name (find first space, chars > 32)
    while getbyte(cmd, pos) > 32 {
        pos = pos + 1
    }
    
    // Skip spaces after program name
    while getbyte(cmd, pos) == 32 {
        pos = pos + 1
    }
    
    // Check if no args
    if getbyte(cmd, pos) == 0 {
        io_println("Error: No input file specified!")
        io_println("Usage: synapse.exe input.syn [-o output.exe]")
        return 1
    }
    
    // Copy input filename
    let i = 0
    while getbyte(cmd, pos) > 32 {
        setbyte(input_file, i, getbyte(cmd, pos))
        i = i + 1
        pos = pos + 1
    }
    setbyte(input_file, i, 0)
    
    // Skip spaces after input filename
    while getbyte(cmd, pos) == 32 {
        pos = pos + 1
    }
    
    // Check for -o flag: '-' = 45, 'o' = 111
    if getbyte(cmd, pos) == 45 {
        if getbyte(cmd, pos + 1) == 111 {
            pos = pos + 2
            // Skip spaces after -o
            while getbyte(cmd, pos) == 32 {
                pos = pos + 1
            }
            // Copy output filename
            i = 0
            while getbyte(cmd, pos) > 32 {
                setbyte(output_file, i, getbyte(cmd, pos))
                i = i + 1
                pos = pos + 1
            }
            setbyte(output_file, i, 0)
        }
    }
    
    // Print parsed files
    io_print("Input:  ")
    io_println(input_file)
    io_print("Output: ")
    io_println(output_file)
    io_println("")
    
    // Read source file
    io_print("Reading ")
    io_println(input_file)
    
    let fd = open(input_file, 0)
    if fd == 0 {
        io_println("Error: Cannot open input file!")
        return 1
    }
    let source = alloc(8192)
    let bytes_read = read(fd, source, 8192)
    close(fd)
    
    io_println("Source loaded!")
    
    // Build EXE
    io_print("Building ")
    io_print(output_file)
    io_println("...")
    
    let state = alloc(64)
    init_state(state)
    
    emit_pe_header(state)
    
    // Write code that calls GetCommandLineA and prints it!
    let exe_buf = state[5]
    let code_start = 512
    
    // SUB RSP, 56
    setbyte(exe_buf, code_start + 0, 72)
    setbyte(exe_buf, code_start + 1, 131)
    setbyte(exe_buf, code_start + 2, 236)
    setbyte(exe_buf, code_start + 3, 56)
    
    // CALL [GetCommandLineA] - IAT[8] at RVA 0x2068
    // RIP after = 0x1000 + 4 + 6 = 0x100A
    // Displacement = 0x2068 - 0x100A = 0x105E
    setbyte(exe_buf, code_start + 4, 255)
    setbyte(exe_buf, code_start + 5, 21)
    setbyte(exe_buf, code_start + 6, 94)   // 0x5E
    setbyte(exe_buf, code_start + 7, 16)   // 0x10
    setbyte(exe_buf, code_start + 8, 0)
    setbyte(exe_buf, code_start + 9, 0)
    
    // MOV R12, RAX (save command line pointer)
    setbyte(exe_buf, code_start + 10, 73)
    setbyte(exe_buf, code_start + 11, 137)
    setbyte(exe_buf, code_start + 12, 196)
    
    // MOV ECX, -11 (STD_OUTPUT_HANDLE)
    setbyte(exe_buf, code_start + 13, 185)
    setbyte(exe_buf, code_start + 14, 245)
    setbyte(exe_buf, code_start + 15, 255)
    setbyte(exe_buf, code_start + 16, 255)
    setbyte(exe_buf, code_start + 17, 255)
    
    // CALL [GetStdHandle] - IAT[7] at RVA 0x2060
    // RIP after = 0x1000 + 18 + 6 = 0x1018
    // Displacement = 0x2060 - 0x1018 = 0x1048
    setbyte(exe_buf, code_start + 18, 255)
    setbyte(exe_buf, code_start + 19, 21)
    setbyte(exe_buf, code_start + 20, 72)   // 0x48
    setbyte(exe_buf, code_start + 21, 16)   // 0x10
    setbyte(exe_buf, code_start + 22, 0)
    setbyte(exe_buf, code_start + 23, 0)
    
    // MOV R13, RAX (save stdout handle)
    setbyte(exe_buf, code_start + 24, 73)
    setbyte(exe_buf, code_start + 25, 137)
    setbyte(exe_buf, code_start + 26, 197)
    
    // WriteFile(handle, buffer, length, &written, NULL)
    // MOV RCX, R13 (handle)
    setbyte(exe_buf, code_start + 27, 76)
    setbyte(exe_buf, code_start + 28, 137)
    setbyte(exe_buf, code_start + 29, 233)
    
    // MOV RDX, R12 (command line pointer)
    setbyte(exe_buf, code_start + 30, 76)
    setbyte(exe_buf, code_start + 31, 137)
    setbyte(exe_buf, code_start + 32, 226)
    
    // MOV R8D, 50 (write 50 chars)
    setbyte(exe_buf, code_start + 33, 65)
    setbyte(exe_buf, code_start + 34, 184)
    setbyte(exe_buf, code_start + 35, 50)
    setbyte(exe_buf, code_start + 36, 0)
    setbyte(exe_buf, code_start + 37, 0)
    setbyte(exe_buf, code_start + 38, 0)
    
    // LEA R9, [RSP+48]
    setbyte(exe_buf, code_start + 39, 76)
    setbyte(exe_buf, code_start + 40, 141)
    setbyte(exe_buf, code_start + 41, 76)
    setbyte(exe_buf, code_start + 42, 36)
    setbyte(exe_buf, code_start + 43, 48)
    
    // MOV QWORD [RSP+32], 0
    setbyte(exe_buf, code_start + 44, 72)
    setbyte(exe_buf, code_start + 45, 199)
    setbyte(exe_buf, code_start + 46, 68)
    setbyte(exe_buf, code_start + 47, 36)
    setbyte(exe_buf, code_start + 48, 32)
    setbyte(exe_buf, code_start + 49, 0)
    setbyte(exe_buf, code_start + 50, 0)
    setbyte(exe_buf, code_start + 51, 0)
    setbyte(exe_buf, code_start + 52, 0)
    
    // CALL [WriteFile] - IAT[3] at RVA 0x2040
    // RIP after = 0x1000 + 53 + 6 = 0x103B
    // Displacement = 0x2040 - 0x103B = 0x1005
    setbyte(exe_buf, code_start + 53, 255)
    setbyte(exe_buf, code_start + 54, 21)
    setbyte(exe_buf, code_start + 55, 5)
    setbyte(exe_buf, code_start + 56, 16)
    setbyte(exe_buf, code_start + 57, 0)
    setbyte(exe_buf, code_start + 58, 0)
    
    // XOR ECX, ECX (exit code 0)
    setbyte(exe_buf, code_start + 59, 49)
    setbyte(exe_buf, code_start + 60, 201)
    
    // CALL [ExitProcess] - IAT[0] at RVA 0x2028
    // RIP after = 0x1000 + 61 + 6 = 0x1043
    // Displacement = 0x2028 - 0x1043 = 0x0FE5
    setbyte(exe_buf, code_start + 61, 255)
    setbyte(exe_buf, code_start + 62, 21)
    setbyte(exe_buf, code_start + 63, 229)   // 0xE5
    setbyte(exe_buf, code_start + 64, 15)    // 0x0F
    setbyte(exe_buf, code_start + 65, 0)
    setbyte(exe_buf, code_start + 66, 0)
    
    state[6] = 1024
    emit_import_table(state)
    
    // Save to output file (from CLI or default "out.exe")
    save_exe(state, output_file)
    
    io_print("Created ")
    io_println(output_file)
    io_println("")
    io_println("Run: <output> arg1 arg2")
    io_println("Should print the command line!")
    
    return 0
}
