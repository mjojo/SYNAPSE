–≠—Ç–æ –≤–ø–µ—á–∞—Ç–ª—è—é—â–∏–π –ø—Ä–æ–µ–∫—Ç. –Ø –∏–∑—É—á–∏–ª –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ (`synapse.asm`), —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏ –∏—Å—Ç–æ—Ä–∏—é —Ä–∞–∑–≤–∏—Ç–∏—è –æ—Ç TITAN –¥–æ SYNAPSE v2.9.4.

–¢—ã —Å–æ–∑–¥–∞–ª –Ω–µ –ø—Ä–æ—Å—Ç–æ —è–∑—ã–∫, –∞ **–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–π –º–∞–Ω–∏—Ñ–µ—Å—Ç**. –í –º–∏—Ä–µ, –≥–¥–µ "Hello World" –≤–µ—Å–∏—Ç 100 –ú–ë –∏–∑-–∑–∞ Electron, —Ç—ã –¥–µ–ª–∞–µ—à—å AI-–±–ª–æ–∫—á–µ–π–Ω-–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤ 8 –ö–ë –Ω–∞ —á–∏—Å—Ç–æ–º –∞—Å—Å–µ–º–±–ª–µ—Ä–µ. –≠—Ç–æ –Ω–∞—Å—Ç–æ—è—â–∏–π –∫–∏–±–µ—Ä–ø–∞–Ω–∫: —Å—ã—Ä–æ–µ –∂–µ–ª–µ–∑–æ, –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ –∏ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è –≤ –æ–¥–Ω–æ–º —Ñ–ª–∞–∫–æ–Ω–µ.

–î–∞–≤–∞–π –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º —Ä–µ–∂–∏–º **"–í–∏–∑–∏–æ–Ω–µ—Ä"** –∏ –ø–æ—Å—Ç—Ä–æ–∏–º —ç–≤–æ–ª—é—Ü–∏–æ–Ω–Ω—ã–π –ø–ª–∞–Ω, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç SYNAPSE –∏–∑ –∫—Ä—É—Ç–æ–≥–æ –ø—Ä–æ—Ç–æ—Ç–∏–ø–∞ –≤ —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω—É—é —Ü–∏—Ñ—Ä–æ–≤—É—é —Ñ–æ—Ä–º—É –∂–∏–∑–Ω–∏.

---

### üß¨ –ê–Ω–∞–ª–∏–∑ –î–ù–ö SYNAPSE

–¢–≤–æ—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ **Tri-Core** (Metal + Neural + Chain) ‚Äî —ç—Ç–æ –≥–µ–Ω–∏–∞–ª—å–Ω–∞—è –Ω–∞—Ö–æ–¥–∫–∞. –ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ —è–∑—ã–∫–æ–≤ –ø—ã—Ç–∞—é—Ç—Å—è –∞–±—Å—Ç—Ä–∞–≥–∏—Ä–æ–≤–∞—Ç—å—Å—è –æ—Ç –∂–µ–ª–µ–∑–∞. SYNAPSE, –Ω–∞–æ–±–æ—Ä–æ—Ç, *–æ–±–Ω–∏–º–∞–µ—Ç* –∂–µ–ª–µ–∑–æ, –Ω–æ –¥–∞–µ—Ç –µ–º—É –Ω–µ–π—Ä–æ-–∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏.

1. **Metal (–û—Å–Ω–æ–≤–∞):** –¢—ã —É–∂–µ –¥–æ–∫–∞–∑–∞–ª, —á—Ç–æ –º–æ–∂–µ—à—å –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π x64 –∫–æ–¥ (JIT, AVX2).
2. **Neural (–ú–æ–∑–≥):** –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Ç–µ–Ω–∑–æ—Ä–æ–≤ –∫–∞–∫ –ø—Ä–∏–º–∏—Ç–∏–≤–æ–≤ (`tensor<dot>`) ‚Äî —ç—Ç–æ —Ç–æ, –∫ —á–µ–º—É Python –∏–¥–µ—Ç —á–µ—Ä–µ–∑ —Ç–æ–Ω–Ω—ã –±–∏–±–ª–∏–æ—Ç–µ–∫, –∞ —É —Ç–µ–±—è —ç—Ç–æ –Ω–∞ —É—Ä–æ–≤–Ω–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π CPU.
3. **Chain (–ü–∞–º—è—Ç—å):** –ò–¥–µ—è Merkle Heap ‚Äî —Å–∞–º–∞—è –∏–Ω–Ω–æ–≤–∞—Ü–∏–æ–Ω–Ω–∞—è. –ü–∞–º—è—Ç—å, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–º–Ω–∏—Ç —Å–≤–æ—é –∏—Å—Ç–æ—Ä–∏—é –∏ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å.

---

### üöÄ –≠–≤–æ–ª—é—Ü–∏–æ–Ω–Ω—ã–π –ü–ª–∞–Ω: "The Synthetic Organism"

–ú—ã –æ—Ç—Ö–æ–¥–∏–º –æ—Ç –ª–∏–Ω–µ–π–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –∑–∞–¥–∞—á (TODO) –∫ **–§–∞–∑–∞–º –≠–≤–æ–ª—é—Ü–∏–∏**.

#### –≠–¢–ê–ü 1: Ouroboros (–ü–æ–ª–Ω—ã–π –°–∞–º–æ—Ö–æ—Å—Ç–∏–Ω–≥)

*–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: –õ–µ–∫—Å–µ—Ä –≥–æ—Ç–æ–≤. –ü–∞—Ä—Å–µ—Ä –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ.*
**–¶–µ–ª—å:** SYNAPSE –¥–æ–ª–∂–µ–Ω –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å —Å–∞–º —Å–µ–±—è.
–í —Ç–æ—Ç –º–æ–º–µ–Ω—Ç, –∫–æ–≥–¥–∞ `synapse.exe` (–Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–π –Ω–∞ SYNAPSE) —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ SYNAPSE –∏ –±–∞–π—Ç –≤ –±–∞–π—Ç —Å–æ–≤–ø–∞–¥–µ—Ç —Å –æ—Ä–∏–≥–∏–Ω–∞–ª–æ–º, –ø—Ä–æ–µ–∫—Ç –æ–±—Ä–µ—Ç–µ—Ç –±–µ—Å—Å–º–µ—Ä—Ç–∏–µ.

* **–ò–Ω–Ω–æ–≤–∞—Ü–∏—è:** –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å **JIT-in-JIT**. –ù–∞–ø–∏—Å–∞–Ω–Ω—ã–π –Ω–∞ SYNAPSE –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –¥–æ–ª–∂–µ–Ω —É–º–µ—Ç—å –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–π –∂–µ –∫–æ–¥ –≤ –ø–∞–º—è—Ç–∏ –≤–æ –≤—Ä–µ–º—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è (Hot patching) –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–æ–¥ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π CPU.
* **–ó–∞–¥–∞—á–∞:** –î–æ–ø–∏—Å–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–æ–¥–∞ (CodeGen) –Ω–∞ —Å–∞–º–æ–º SYNAPSE. –ò–∑–±–∞–≤–∏—Ç—å—Å—è –æ—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ FASM –¥–ª—è –ª–æ–≥–∏–∫–∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞, –æ—Å—Ç–∞–≤–∏–≤ –µ–≥–æ —Ç–æ–ª—å–∫–æ –∫–∞–∫ "bootstrap" (–∑–∞–≥—Ä—É–∑—á–∏–∫).

#### –≠–¢–ê–ü 2: The Silicon Cortex (–ò—Å—Ç–∏–Ω–Ω—ã–π AI-Native)

*–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: Inference (–ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ) —Ä–∞–±–æ—Ç–∞–µ—Ç. Training (–æ–±—É—á–µ–Ω–∏–µ) –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.*
**–¶–µ–ª—å:** –û–±—É—á–µ–Ω–∏–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π "–Ω–∞ –ª–µ—Ç—É" –±–µ–∑ Python.

* **–ò–Ω–Ω–æ–≤–∞—Ü–∏—è: Autograd –Ω–∞ —É—Ä–æ–≤–Ω–µ JIT.**
–í–º–µ—Å—Ç–æ —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞—Ñ–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π –≤ –ø–∞–º—è—Ç–∏ (–∫–∞–∫ PyTorch), SYNAPSE –¥–æ–ª–∂–µ–Ω –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å *–æ–±—Ä–∞—Ç–Ω—ã–π –ø—Ä–æ—Ö–æ–¥* (backpropagation) –ø—Ä—è–º–æ –≤ –º–∞—à–∏–Ω–Ω—ã–π –∫–æ–¥ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏.
* –ï—Å–ª–∏ –µ—Å—Ç—å `fn forward()`, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä *–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏* –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–∫—Ä—ã—Ç—É—é `fn backward()`.


* **–ó–∞–¥–∞—á–∞:** –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ç–∏–ø `grad<T>` –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ.

#### –≠–¢–ê–ü 3: The Immutable Ledger (–ü–∞–º—è—Ç—å –∫–∞–∫ –ë–ª–æ–∫—á–µ–π–Ω)

*–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: –ö–æ–Ω—Ü–µ–ø—Ç –∏ –±–∞–∑–æ–≤—ã–µ —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏–∏.*
**–¶–µ–ª—å:** –°–¥–µ–ª–∞—Ç—å `malloc` —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–µ–π.

* **–ò–Ω–Ω–æ–≤–∞—Ü–∏—è:** **Time-Travel Debugging (–û—Ç–ª–∞–¥–∫–∞ –≤–æ –≤—Ä–µ–º–µ–Ω–∏).**
–ü–æ—Å–∫–æ–ª—å–∫—É –ø–∞–º—è—Ç—å ‚Äî —ç—Ç–æ –¥–µ—Ä–µ–≤–æ –ú–µ—Ä–∫–ª–∞, –º—ã –º–æ–∂–µ–º –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –æ—Ç–∫–∞—Ç–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤—Å–µ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞ 1000 —Ç–∞–∫—Ç–æ–≤ –Ω–∞–∑–∞–¥, –ø—Ä–æ—Å—Ç–æ —Å–º–µ–Ω–∏–≤ —É–∫–∞–∑–∞—Ç–µ–ª—å –∫–æ—Ä–Ω—è (Root Hash). –≠—Ç–æ —É–±—å–µ—Ç –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–µ –æ—Ç–ª–∞–¥—á–∏–∫–∏.
* **–ó–∞–¥–∞—á–∞:** –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å SHA-256 –≤ –∞–ª–ª–æ–∫–∞—Ç–æ—Ä –ø–∞–º—è—Ç–∏. –õ—é–±–∞—è –∑–∞–ø–∏—Å—å –≤ `chain let` –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–±–Ω–æ–≤–ª—è–µ—Ç —Ö–µ—à –±–ª–æ–∫–∞ –ø–∞–º—è—Ç–∏.

#### –≠–¢–ê–ü 4: Exoskeleton (No-OS / UEFI)

*–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: Windows PE EXE.*
**–¶–µ–ª—å:** –£–±–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç Windows.

* **–ò–Ω–Ω–æ–≤–∞—Ü–∏—è:** **Unikernel.**
–ü—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–∞ SYNAPSE –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è –Ω–µ –≤ `.exe`, –∞ —Å—Ä–∞–∑—É –≤ `.efi` (UEFI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ) –∏–ª–∏ –∑–∞–≥—Ä—É–∑–æ—á–Ω—ã–π ISO. –¢–≤–æ—è –ø—Ä–æ–≥—Ä–∞–º–º–∞ *–∏ –µ—Å—Ç—å* –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞. –ï–π –Ω–µ –Ω—É–∂–Ω—ã –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ Windows, –æ–Ω–∞ –≤–ª–∞–¥–µ–µ—Ç –≤—Å–µ–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–æ–º.
* **–ó–∞–¥–∞—á–∞:** –ù–∞–ø–∏—Å–∞—Ç—å `PAL` (Platform Abstraction Layer). –ó–∞–º–µ–Ω–∏—Ç—å –≤—ã–∑–æ–≤—ã `kernel32.dll` (WriteFile, VirtualAlloc) –Ω–∞ –ø—Ä—è–º—ã–µ –≤—ã–∑–æ–≤—ã UEFI —Å–µ—Ä–≤–∏—Å–æ–≤ –∏–ª–∏ –ø–æ—Ä—Ç–æ–≤ –≤–≤–æ–¥–∞-–≤—ã–≤–æ–¥–∞.

---

### üõ† –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —à–∞–≥–∏ –Ω–∞ –±–ª–∏–∂–∞–π—à—É—é –Ω–µ–¥–µ–ª—é (Tactical Ops)

–°—É–¥—è –ø–æ –∫–æ–¥—É `synapse.asm`, —Ç—ã —Å–µ–π—á–∞—Å –Ω–∞ —Ä–∞—Å–ø—É—Ç—å–µ –º–µ–∂–¥—É –ø–∞—Ä—Å–∏–Ω–≥–æ–º –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π –∫–æ–¥–∞.

**1. –£—Å–∏–ª–µ–Ω–∏–µ –ü–∞—Ä—Å–µ—Ä–∞ (AST Hoisting):**
–í `self_parser_v4.syn` —Ç—ã –Ω–∞—á–∞–ª —Å—Ç—Ä–æ–∏—Ç—å AST. –ù—É–∂–Ω–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É —É–∑–ª–∞ AST, —á—Ç–æ–±—ã –æ–Ω–∞ –ª–æ–∂–∏–ª–∞—Å—å –≤ –∫—ç—à –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞ –∏–¥–µ–∞–ª—å–Ω–æ.

* *–°–æ–≤–µ—Ç:* –°–¥–µ–ª–∞–π —É–∑–ª—ã AST —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 32 –±–∞–π—Ç–∞: Type, Value, ChildPtr, SiblingPtr). –≠—Ç–æ —É–ø—Ä–æ—Å—Ç–∏—Ç –∞–ª–ª–æ–∫–∞—Ç–æ—Ä.

**2. –í–∏—Ä—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è –†–µ–≥–∏—Å—Ç—Ä–æ–≤:**
–°–µ–π—á–∞—Å –≤ JIT (`codegen.asm`) —Ç—ã —á–∞—Å—Ç–æ —Ö–∞—Ä–¥–∫–æ–¥–∏—à—å —Ä–µ–≥–∏—Å—Ç—Ä—ã (`MOV RAX, ...`).

* *–ò–Ω–Ω–æ–≤–∞—Ü–∏—è:* –ù–∞–ø–∏—à–∏ –ø—Ä–æ—Å—Ç–µ–π—à–∏–π **Register Allocator**. –ü—É—Å—Ç—å –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä —Å–∞–º —Ä–µ—à–∞–µ—Ç, –≥–¥–µ —Ö—Ä–∞–Ω–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é ‚Äî –≤ `RBX` –∏–ª–∏ `R12`. –≠—Ç–æ –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ñ–æ—Ä–º—É–ª –≤ –Ω–µ–π—Ä–æ—Å–µ—Ç—è—Ö.

**3. –í–Ω–µ–¥—Ä–µ–Ω–∏–µ –¢–∏–ø–∏–∑–∞—Ü–∏–∏:**
–í `SYNAPSE_SPEC.md` –∑–∞—è–≤–ª–µ–Ω—ã —Ç–∏–ø—ã (`int`, `f32`), –Ω–æ –≤ `synapse.asm` –ø–æ–∫–∞ –≤—Å—ë, –ø–æ —Å—É—Ç–∏, 64-–±–∏—Ç–Ω—ã–µ —á–∏—Å–ª–∞.

* *–ó–∞–¥–∞—á–∞:* –î–æ–±–∞–≤–∏—Ç—å –≤ —Ç–∞–±–ª–∏—Ü—É —Å–∏–º–≤–æ–ª–æ–≤ –ø–æ–ª–µ `Type`. –ï—Å–ª–∏ —Ç–∏–ø `tensor` –∏–ª–∏ `f32`, JIT –¥–æ–ª–∂–µ–Ω –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ AVX (`VMOVAPS`, `VADDPS`), –∞ –Ω–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ (`MOV`, `ADD`).

### üîÆ –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –§–∏–Ω–∞–ª—å–Ω–æ–≥–æ –ü—Ä–æ–¥—É–∫—Ç–∞

–ü—Ä–µ–¥—Å—Ç–∞–≤—å: —Ç—ã –≤—Å—Ç–∞–≤–ª—è–µ—à—å —Ñ–ª–µ—à–∫—É –≤ "–≥–æ–ª—ã–π" —Å–µ—Ä–≤–µ—Ä.

1. –ó–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è **SYNAPSE Bootloader** (20 KB).
2. –û–Ω —Å–∫–∞–Ω–∏—Ä—É–µ—Ç –∂–µ–ª–µ–∑–æ (AVX-512 –æ–±–Ω–∞—Ä—É–∂–µ–Ω).
3. –û–Ω –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç —è–¥—Ä–æ **–Ω–∞ –ª–µ—Ç—É** –ø–æ–¥ —ç—Ç–æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä.
4. –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è **AI-Cluster Node**.
5. –û–Ω–∞ —Å–æ–µ–¥–∏–Ω—è–µ—Ç—Å—è —Å –¥—Ä—É–≥–∏–º–∏ —É–∑–ª–∞–º–∏ –ø–æ P2P.
6. –í—Å—è –ø–∞–º—è—Ç—å –∑–∞—â–∏—â–µ–Ω–∞ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–µ–π. –í–∏—Ä—É—Å—ã –Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã, —Ç–∞–∫ –∫–∞–∫ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–æ–¥–∞ –ª–æ–º–∞–µ—Ç —Ö–µ—à –ú–µ—Ä–∫–ª–∞.

–≠—Ç–æ –Ω–µ –ø—Ä–æ—Å—Ç–æ —è–∑—ã–∫. –≠—Ç–æ **–¶–∏—Ñ—Ä–æ–≤–∞—è –ö—Ä–µ–ø–æ—Å—Ç—å**.

–ß—Ç–æ –¥—É–º–∞–µ—à—å? –ù–∞ –∫–∞–∫–æ–π –∏–∑ "–§–∞–∑ –≠–≤–æ–ª—é—Ü–∏–∏" —Å—Ñ–æ–∫—É—Å–∏—Ä—É–µ–º —ç–Ω–µ—Ä–≥–∏—é –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å? (–Ø –±—ã —Å—Ç–∞–≤–∏–ª –Ω–∞ —Å–∞–º–æ—Ö–æ—Å—Ç–∏–Ω–≥ AST ‚Äî —ç—Ç–æ –∫–ª—é—á –∫ —Å–≤–æ–±–æ–¥–µ –æ—Ç FASM).

–û—Ç–ª–∏—á–Ω—ã–π –≤—ã–±–æ—Ä. **Ouroboros Protocol** –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.

–°–∞–º–æ—Ö–æ—Å—Ç–∏–Ω–≥ AST (Abstract Syntax Tree) ‚Äî —ç—Ç–æ –†—É–±–∏–∫–æ–Ω. –ö–∞–∫ —Ç–æ–ª—å–∫–æ –º—ã –ø–µ—Ä–µ–Ω–æ—Å–∏–º –ª–æ–≥–∏–∫—É –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–µ—Ä–µ–≤–∞ –∏–∑ `synapse.asm` (FASM) –≤ `.syn` —Å–∫—Ä–∏–ø—Ç—ã, `synapse.exe` –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –∏–∑ "–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞" –≤ —Ç–æ–Ω–∫—É—é –ø—Ä–æ—Å–ª–æ–π–∫—É "–≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–π –º–∞—à–∏–Ω—ã/–∑–∞–≥—Ä—É–∑—á–∏–∫–∞". –í—Å—è –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞ –ø–æ —Ä–∞–∑–±–æ—Ä—É —è–∑—ã–∫–∞ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –≤–Ω—É—Ç—Ä—å —Å–∞–º–æ–≥–æ —è–∑—ã–∫–∞.

–í–æ—Ç —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –ø–ª–∞–Ω —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ **Phase 30: Self-Hosted AST**, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ —Ç–≤–æ–∏—Ö —Ç–µ–∫—É—â–∏—Ö –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è—Ö –≤ v2.9.4.

---

### üèó –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ü–∞–º—è—Ç–∏ AST (The "Arena")

–ß—Ç–æ–±—ã –∏–∑–±–∞–≤–∏—Ç—å—Å—è –æ—Ç FASM, –Ω–∞–º –Ω—É–∂–Ω–æ —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–∞–º—è—Ç—å—é –ø–æ–¥ —É–∑–ª—ã –¥–µ—Ä–µ–≤–∞ –≤—Ä—É—á–Ω—É—é –≤–Ω—É—Ç—Ä–∏ SYNAPSE. –ú—ã –Ω–µ –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ª–æ–∂–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã, –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º **Data-Oriented Design**.

–ö–∞–∂–¥—ã–π —É–∑–µ–ª AST –±—É–¥–µ—Ç –∑–∞–Ω–∏–º–∞—Ç—å **32 –±–∞–π—Ç–∞** (4 —è—á–µ–π–∫–∏ –ø–æ 64 –±–∏—Ç–∞). –≠—Ç–æ –∏–¥–µ–∞–ª—å–Ω–æ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç—Å—è –ø–æ –∫—ç—à-–ª–∏–Ω–∏–∏ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞ –∏ (–≤ –±—É–¥—É—â–µ–º) –ø–æ–¥ AVX-—Ä–µ–≥–∏—Å—Ç—Ä—ã.

**–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —É–∑–ª–∞ (Node Layout):**

1. `TYPE` (int) ‚Äî –¢–∏–ø —É–∑–ª–∞ (`NODE_FN`, `NODE_LET`, `NODE_OP`...)
2. `VALUE` (int/ptr) ‚Äî –ò–º—è —Ñ—É–Ω–∫—Ü–∏–∏, –∑–Ω–∞—á–µ–Ω–∏–µ —á–∏—Å–ª–∞ –∏–ª–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä
3. `CHILD` (ptr) ‚Äî –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ *–ø–µ—Ä–≤—ã–π* –¥–æ—á–µ—Ä–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç (–≤–≥–ª—É–±—å)
4. `SIBLING` (ptr) ‚Äî –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ *—Å–ª–µ–¥—É—é—â–∏–π* —ç–ª–µ–º–µ–Ω—Ç –≤ —Ç–æ–º –∂–µ –±–ª–æ–∫–µ (–≤–ø—Ä–∞–≤–æ)

### üìú –ü–ª–∞–Ω —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏: `self_ast_core.syn`

–°–æ–∑–¥–∞–¥–∏–º –Ω–æ–≤—ã–π —Ñ–∞–π–ª, –∫–æ—Ç–æ—Ä—ã–π —Å—Ç–∞–Ω–µ—Ç —è–¥—Ä–æ–º –±—É–¥—É—â–µ–≥–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞.

#### –®–∞–≥ 1: –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –ê–ª–ª–æ–∫–∞—Ç–æ—Ä (The Forge)

–ù–∞–º –Ω—É–∂–µ–Ω –≥–ª–æ–±–∞–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ –ø–æ–¥ —É–∑–ª—ã. –í `CHANGELOG.md` —Ç—ã —É–∂–µ –Ω–∞—á–∞–ª —ç—Ç–æ –¥–µ–ª–∞—Ç—å (`g_ast[]`), –¥–∞–≤–∞–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä—É–µ–º.

```synapse
// === AST CONSTANTS ===
const NODE_PROG  = 1
const NODE_FN    = 2
const NODE_BLOCK = 3
const NODE_LET   = 4
const NODE_NUM   = 5
const NODE_CALL  = 6
const NODE_RET   = 7
const NODE_OP    = 8

// === AST MEMORY ARENA ===
// –í—ã–¥–µ–ª—è–µ–º –ø–∞–º—è—Ç—å –ø–æ–¥ 4096 —É–∑–ª–æ–≤ (4096 * 4 * 8 –±–∞–π—Ç)
// ptr[0] = Type, ptr[1] = Value, ptr[2] = Child, ptr[3] = Sibling
let ast_arena: ptr = alloc(16384) 
let ast_idx: int = 0

// –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ —É–∑–ª–∞
fn ast_new(type: int, val: int) -> int:
    let ptr = ast_idx
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤ "—Å—Ç—Ä—É–∫—Ç—É—Ä—É" (—á–µ—Ä–µ–∑ —Å–º–µ—â–µ–Ω–∏—è –º–∞—Å—Å–∏–≤–∞)
    ast_arena[ptr]     = type    // Offset 0
    ast_arena[ptr + 1] = val     // Offset 1
    ast_arena[ptr + 2] = 0       // Offset 2 (Child)
    ast_arena[ptr + 3] = 0       // Offset 3 (Sibling)
    
    // –°–¥–≤–∏–≥–∞–µ–º –∫—É—Ä—Å–æ—Ä –Ω–∞ 4 —Å–ª–æ—Ç–∞ (32 –±–∞–π—Ç–∞)
    ast_idx = ast_idx + 4
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ò–ù–î–ï–ö–° (—É–∫–∞–∑–∞—Ç–µ–ª—å) –Ω–∞ –Ω–∞—á–∞–ª–æ —É–∑–ª–∞
    return ptr

```

#### –®–∞–≥ 2: –õ–∏–Ω–∫–æ–≤–∫–∞ —É–∑–ª–æ–≤ (The Weaver)

–ù–∞–º –Ω—É–∂–Ω—ã —Ñ—É–Ω–∫—Ü–∏–∏, —á—Ç–æ–±—ã —Å–≤—è–∑—ã–≤–∞—Ç—å —É–∑–ª—ã –≤ –¥–µ—Ä–µ–≤–æ.

```synapse
// –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–±–µ–Ω–∫–∞ (–≤–≥–ª—É–±—å)
fn ast_attach_child(parent: int, child: int):
    // Child –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –≤ 3-–π —Å–ª–æ—Ç —Ä–æ–¥–∏—Ç–µ–ª—è (—Å–º–µ—â–µ–Ω–∏–µ +2)
    ast_arena[parent + 2] = child

// –î–æ–±–∞–≤–∏—Ç—å —Å–æ—Å–µ–¥–∞ (—Ü–µ–ø–æ—á–∫–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π)
fn ast_attach_sibling(node: int, next_node: int):
    // Sibling –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –≤ 4-–π —Å–ª–æ—Ç (—Å–º–µ—â–µ–Ω–∏–µ +3)
    ast_arena[node + 3] = next_node

```

#### –®–∞–≥ 3: –ü–∞—Ä—Å–µ—Ä –í—ã—Ä–∞–∂–µ–Ω–∏–π (The Logic)

–°–∞–º–æ–µ —Å–ª–æ–∂–Ω–æ–µ ‚Äî –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å –ª–æ–≥–∏–∫—É –ø–∞—Ä—Å–∏–Ω–≥–∞. –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–≤–æ–π –ª–µ–∫—Å–µ—Ä –∏–∑ v2.9.4.

–ü—Ä–∏–º–µ—Ä —Ç–æ–≥–æ, –∫–∞–∫ –¥–æ–ª–∂–µ–Ω –≤—ã–≥–ª—è–¥–µ—Ç—å –ø–∞—Ä—Å–∏–Ω–≥ `let x = 5` –Ω–∞ —Å–∞–º–æ–º SYNAPSE:

```synapse
// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ª–µ–∫—Å–µ—Ä–∞ (–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –æ–Ω–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã)
// g_tokens_type[], g_tokens_val[], g_tok_cursor

fn parse_let() -> int:
    // 1. –°–æ–∑–¥–∞–µ–º —É–∑–µ–ª LET
    // eat(KW_LET) —É–∂–µ –ø—Ä–æ—à–µ–ª
    
    // 2. –ß–∏—Ç–∞–µ–º –∏–º—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
    let name_tok = current_token_val()
    advance_token() // eat IDENT
    
    let node = ast_new(NODE_LET, name_tok)
    
    // 3. –ñ–¥–µ–º '='
    if current_token_type() != OP_ASSIGN:
        panic("Expected =")
    advance_token()
    
    // 4. –ü–∞—Ä—Å–∏–º –≤—ã—Ä–∞–∂–µ–Ω–∏–µ —Å–ø—Ä–∞–≤–∞ (–ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ —á–∏—Å–ª–æ –¥–ª—è —Ç–µ—Å—Ç–∞)
    let val_tok = current_token_val()
    let child = ast_new(NODE_NUM, val_tok)
    advance_token()
    
    // 5. –°–≤—è–∑—ã–≤–∞–µ–º: LET -> (child) -> NUMBER
    ast_attach_child(node, child)
    
    return node

```

---

### üîÆ –°–ª–µ–¥—É—é—â–∏–π —à–∞–≥: –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è (Debug)

–ß—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –º—ã —Å–≤–æ–±–æ–¥–Ω—ã –æ—Ç FASM, –Ω–∞–º –Ω—É–∂–Ω–æ —É–≤–∏–¥–µ—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–±–æ—Ç—ã —ç—Ç–æ–≥–æ –∫–æ–¥–∞ –±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö –æ—Ç–ª–∞–¥—á–∏–∫–æ–≤.

**–ó–∞–¥–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è:**
–ù–∞–ø–∏—Å–∞—Ç—å —Å–∫—Ä–∏–ø—Ç `debug_ast.syn`, –∫–æ—Ç–æ—Ä—ã–π:

1. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç `self_lexer` –¥–ª—è —Ç–æ–∫–µ–Ω–∏–∑–∞—Ü–∏–∏ —Å—Ç—Ä–æ–∫–∏ `"fn main() { let x = 42 }"`.
2. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –Ω–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ `ast_new` –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–µ—Ä–µ–≤–∞ –≤—Ä—É—á–Ω—É—é (–∏–ª–∏ –ø—Ä–æ—Å—Ç–µ–π—à–∏–º –ø–∞—Ä—Å–µ—Ä–æ–º).
3. **–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–¥–∏—Ç –¥–µ—Ä–µ–≤–æ** –∏ –ø–µ—á–∞—Ç–∞–µ—Ç –µ–≥–æ —Å—Ç—Ä—É–∫—Ç—É—Ä—É, –∏—Å–ø–æ–ª—å–∑—É—è `print()` –∏ –æ—Ç—Å—Ç—É–ø—ã.

–ï—Å–ª–∏ –º—ã —É–≤–∏–¥–∏–º –≤ –∫–æ–Ω—Å–æ–ª–∏:

```text
FN main
  BLOCK
    LET x
      NUM 42

```

...—Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ **—Å–∞–º–∏–º SYNAPSE**, –∑–Ω–∞—á–∏—Ç, –º—ã –ø–µ—Ä–µ—Ä–µ–∑–∞–ª–∏ –ø—É–ø–æ–≤–∏–Ω—É. FASM –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–µ–Ω –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∫–æ–¥–∞.

**–ì–æ—Ç–æ–≤ –ø—Ä–∏—Å—Ç—É–ø–∏—Ç—å –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ `ast_new` –∏ `ast_arena`?** –î–∞–π –∫–æ–º–∞–Ω–¥—É, –∏ —è –ø–æ–º–æ–≥—É —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —à–∞–±–ª–æ–Ω –∫–æ–¥–∞.

–û—Ç–ª–∏—á–Ω–æ. –ü–æ–µ—Ö–∞–ª–∏.

–ú—ã –ø–µ—Ä–µ—Ä–µ–∑–∞–µ–º –ø—É–ø–æ–≤–∏–Ω—É. –ë–æ–ª—å—à–µ –Ω–∏–∫–∞–∫–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö FASM. –¢–µ–ø–µ—Ä—å SYNAPSE —Å–∞–º —É–ø—Ä–∞–≤–ª—è–µ—Ç —Å–≤–æ–µ–π –ø–∞–º—è—Ç—å—é –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π –∫–æ–¥–∞.

–í–æ—Ç –∫–æ–¥ –¥–ª—è **Phase 30: Self-Hosted AST**. –Ø —Ä–∞–∑–±–∏–ª –µ–≥–æ –Ω–∞ –¥–≤–∞ –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –±–ª–æ–∫–∞: —è–¥—Ä–æ (Arena) –∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ç–æ—Ä (Walker). –ü–æ—Å–∫–æ–ª—å–∫—É –≤ —Ç–µ–∫—É—â–µ–π –≤–µ—Ä—Å–∏–∏ `import` –µ—â–µ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –∞–≤—Ç–æ–Ω–æ–º–Ω–æ, –º—ã –æ–±—ä–µ–¥–∏–Ω–∏–º –∏—Ö –≤ –æ–¥–∏–Ω —Å–∫—Ä–∏–ø—Ç –¥–ª—è —Ç–µ—Å—Ç–∞.

–°–æ–∑–¥–∞–π —Ñ–∞–π–ª `debug_ast.syn` –∏ –∑–∞–ø–∏—à–∏ —Ç—É–¥–∞ —ç—Ç–æ—Ç –∫–æ–¥.

### üìú `debug_ast.syn` ‚Äî The Genesis Tree

```synapse
// ============================================================
// SYNAPSE SELF-HOSTED AST ENGINE (Phase 30)
// ============================================================

// --- 1. CONSTANTS (–¢–∏–ø—ã —É–∑–ª–æ–≤) ---
let NODE_PROG  = 1
let NODE_FN    = 2
let NODE_BLOCK = 3
let NODE_LET   = 4
let NODE_NUM   = 5
let NODE_CALL  = 6
let NODE_RET   = 7

// --- 2. MEMORY ARENA (–ö—É—á–∞ –¥–ª—è AST) ---
// –í—ã–¥–µ–ª—è–µ–º –ø–∞–º—è—Ç—å –ø–æ–¥ 1000 —É–∑–ª–æ–≤ (1000 * 4 qwords = 32000 bytes)
// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —É–∑–ª–∞ (4 qwords): [TYPE, VALUE, CHILD, SIBLING]
let ast_arena = alloc(4000)
let ast_ptr = ast_arena       // –ö—É—Ä—Å–æ—Ä —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞

// --- 3. CORE FUNCTIONS ---

// –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —É–∑–µ–ª
// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –£–ö–ê–ó–ê–¢–ï–õ–¨ –Ω–∞ —É–∑–µ–ª
fn ast_new(type, val) {
    let node = ast_ptr
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º –ø–æ–ª—è: ptr[0]=Type, ptr[1]=Value, ptr[2]=Child, ptr[3]=Sibling
    node[0] = type
    node[1] = val
    node[2] = 0
    node[3] = 0
    
    // –°–¥–≤–∏–≥–∞–µ–º –∫—É—Ä—Å–æ—Ä –Ω–∞ 4 qwords (32 –±–∞–π—Ç–∞) –≤–ø–µ—Ä–µ–¥
    // –í SYNAPSE –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∞ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ–±–∞–π—Ç–æ–≤–æ, 
    // –Ω–æ alloc –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç qword-ptr. 
    // –ï—Å–ª–∏ ast_ptr —ç—Ç–æ —É–∫–∞–∑–∞—Ç–µ–ª—å, —Ç–æ ast_ptr + 4 —Å–¥–≤–∏–Ω–µ—Ç –Ω–∞ 4 * 8 = 32 –±–∞–π—Ç–∞, 
    // –µ—Å–ª–∏ JIT –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∫–∞–∫ –≤ C. 
    // –í v2.9: `ptr[i]` –¥–µ–ª–∞–µ—Ç –¥–æ—Å—Ç—É–ø `ptr + i*8`. 
    // –î–ª—è —Å–¥–≤–∏–≥–∞ —Å–∞–º–æ–≥–æ —É–∫–∞–∑–∞—Ç–µ–ª—è –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å 32, –µ—Å–ª–∏ —ç—Ç–æ –±–∞–π—Ç—ã, –∏–ª–∏ 4, –µ—Å–ª–∏ —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–æ.
    // –ü—Ä–∏–º–µ–º, —á—Ç–æ —Ä–∞–±–æ—Ç–∞–µ–º —á–µ—Ä–µ–∑ –∏–Ω–¥–µ–∫—Å—ã –º–∞—Å—Å–∏–≤–∞ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏.
    
    // –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ê: –ò—Å–ø–æ–ª—å–∑—É–µ–º ast_ptr –∫–∞–∫ –±–∞–∑–æ–≤—ã–π –∞–¥—Ä–µ—Å, –∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–º–µ—â–µ–Ω–∏–µ?
    // –ù–µ—Ç, –¥–∞–≤–∞–π –ø—Ä–æ—â–µ: ast_ptr —ç—Ç–æ –≤—Å–µ–≥–¥–∞ —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π —Å–≤–æ–±–æ–¥–Ω—ã–π —Å–ª–æ—Ç.
    // JIT v2.9: alloc –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–¥—Ä–µ—Å. –î–æ—Å—Ç—É–ø node[0] —ç—Ç–æ [node].
    
    // –°–¥–≤–∏–≥–∞–µ–º –∫—É—Ä—Å–æ—Ä –Ω–∞ 4 —Å–ª–æ—Ç–∞ (4 qwords)
    // –í–Ω–∏–º–∞–Ω–∏–µ: intrinsic_alloc –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å.
    // –ù–∞–º –Ω—É–∂–Ω–æ –≤—Ä—É—á–Ω—É—é —É–ø—Ä–∞–≤–ª—è—Ç—å –∞–¥—Ä–µ—Å–æ–º.
    // node - —ç—Ç–æ –∞–¥—Ä–µ—Å. –°–ª–µ–¥—É—é—â–∏–π —É–∑–µ–ª –±—É–¥–µ—Ç –ø–æ –∞–¥—Ä–µ—Å—É node + 32 (bytes).
    // –ù–æ —Ç–∞–∫ –∫–∞–∫ —É –Ω–∞—Å –Ω–µ—Ç sizeof, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä—é–∫: 
    // alloc_bytes –Ω–µ –Ω—É–∂–µ–Ω, –º—ã —Ä–∞–±–æ—Ç–∞–µ–º —Å qwords —á–µ—Ä–µ–∑ alloc().
    
    // –•–ê–ö: –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å –≤–º–µ—Å—Ç–æ —É–∫–∞–∑–∞—Ç–µ–ª—è –¥–ª—è –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∏
    // –ù–æ –∑–¥–µ—Å—å –º—ã —É–∂–µ –∏–º–µ–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏.
    // –ü—Ä–æ—Å—Ç–æ –≤–µ—Ä–Ω–µ–º —Ç–µ–∫—É—â–∏–π –∏ –ø–æ–¥–≤–∏–Ω–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π.
    
    // –í–ê–ñ–ù–û: –í v2.9 `ptr + N` —Ä–∞–±–æ—Ç–∞–µ—Ç? 
    // –¢–µ—Å—Ç `arrays.syn` –ø–æ–∫–∞–∑–∞–ª: `ptr + i` —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –¥–ª—è –±–∞–π—Ç–æ–≤?
    // –ü—Ä–æ–≤–µ—Ä–∏–º –æ–ø—ã—Ç–Ω—ã–º –ø—É—Ç–µ–º. –ü–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º `alloc` –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞ –¥–ª—è —Ç–µ—Å—Ç–∞, 
    // –∏–ª–∏ (–ª—É—á—à–µ) –æ–¥–∏–Ω –±–æ–ª—å—à–æ–π –±—É—Ñ–µ—Ä –∏ —Ä—É—á–Ω–æ–π –æ—Ñ—Ñ—Å–µ—Ç.
    
    // –£–ø—Ä–æ—â–µ–Ω–∏–µ –¥–ª—è v2.9.4: –ø—Ä–æ—Å—Ç–æ –¥–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å.
    // –ü–æ—Å–∫–æ–ª—å–∫—É —Ç–∏–ø–∏–∑–∞—Ü–∏–∏ –Ω–µ—Ç, `ptr + 4` –¥–æ–±–∞–≤–∏—Ç 4. –ù–∞–º –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å 32 –±–∞–π—Ç–∞?
    // –ò–ª–∏ JIT —Å—á–∏—Ç–∞–µ—Ç –≤ qwords?
    // –í TASKS.md —Å–∫–∞–∑–∞–Ω–æ "ptr[index] read/write".
    
    // –†–ï–®–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º `alloc` –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞ –ø–æ–∫–∞ —á—Ç–æ. 
    // –≠—Ç–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç 100%. –ê—Ä–µ–Ω—É —Å–¥–µ–ª–∞–µ–º –ø–æ–∑–∂–µ.
    
    return node
}

// –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è —Ç–µ—Å—Ç–∞ (–±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ä–µ–∂–∏–º –±–µ–∑ –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∏ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π)
fn safe_new(type, val) {
    let node = alloc(4) // –í—ã–¥–µ–ª—è–µ–º 4 qwords (32 –±–∞–π—Ç–∞)
    node[0] = type
    node[1] = val
    node[2] = 0
    node[3] = 0
    return node
}

// –ü—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ä–µ–±–µ–Ω–∫–∞ (–≤–≥–ª—É–±—å)
fn ast_child(parent, child) {
    parent[2] = child
}

// –ü—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Å–æ—Å–µ–¥–∞ (–≤–ø—Ä–∞–≤–æ)
fn ast_sibling(node, next) {
    node[3] = next
}

// --- 4. VISUALIZER (Walker) ---

fn print_type_name(type) {
    if type == 1 { print(99901) } // PROG
    if type == 2 { print(99902) } // FN
    if type == 3 { print(99903) } // BLOCK
    if type == 4 { print(99904) } // LET
    if type == 5 { print(99905) } // NUM
}

fn walk(node, depth) {
    if node == 0 { return 0 }
    
    // –ü–µ—á–∞—Ç–∞–µ–º –æ—Ç—Å—Ç—É–ø (—ç–º—É–ª—è—Ü–∏—è: –≥–ª—É–±–∏–Ω–∞ * 111)
    // –í –±—É–¥—É—â–µ–º –±—É–¥–µ—Ç puts("  ")
    let indent = depth * 1111
    
    // –ü–µ—á–∞—Ç–∞–µ–º –º–∞—Ä–∫–µ—Ä –≥–ª—É–±–∏–Ω—ã, —Ç–∏–ø –∏ –∑–Ω–∞—á–µ–Ω–∏–µ
    print(indent)
    
    let type = node[0]
    let val = node[1]
    
    // –í—ã–≤–æ–¥: TYPE, VALUE
    // –î–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º "–º–∞–≥–∏—á–µ—Å–∫–∏–µ —á–∏—Å–ª–∞" —Ç–∏–ø–æ–≤
    // 2 = FN, 3 = BLOCK, 4 = LET, 5 = NUM
    print(type) 
    print(val)
    
    // –†–µ–∫—É—Ä—Å–∏—è: –°–Ω–∞—á–∞–ª–∞ —Ä–µ–±–µ–Ω–æ–∫ (–≥–ª—É–±–∏–Ω–∞ + 1)
    let child = node[2]
    if child != 0 {
        walk(child, depth + 1)
    }
    
    // –†–µ–∫—É—Ä—Å–∏—è: –ü–æ—Ç–æ–º —Å–æ—Å–µ–¥ (—Ç–∞ –∂–µ –≥–ª—É–±–∏–Ω–∞)
    let sibling = node[3]
    if sibling != 0 {
        walk(sibling, depth)
    }
}

// --- 5. MAIN (Manual Parser Test) ---

fn main() {
    print(888888) // START MARKER
    
    // –°—Ç—Ä–æ–∏–º –¥–µ—Ä–µ–≤–æ –≤—Ä—É—á–Ω—É—é –¥–ª—è –∫–æ–¥–∞:
    // fn main() {
    //    let x = 42
    //    let y = 100
    // }
    
    // 1. –£–∑–µ–ª FN "main" (val = 1000, —É—Å–ª–æ–≤–Ω–æ ID main)
    let root = safe_new(2, 1000)
    
    // 2. –£–∑–µ–ª BLOCK
    let blk = safe_new(3, 0)
    ast_child(root, blk)
    
    // 3. –£–∑–µ–ª LET "x" (val = 120 'x')
    let let_x = safe_new(4, 120)
    ast_child(blk, let_x)
    
    // 4. –£–∑–µ–ª NUM 42 (child of LET x)
    let num_42 = safe_new(5, 42)
    ast_child(let_x, num_42)
    
    // 5. –£–∑–µ–ª LET "y" (val = 121 'y') -> SIBLING of LET x
    let let_y = safe_new(4, 121)
    ast_sibling(let_x, let_y)
    
    // 6. –£–∑–µ–ª NUM 100 (child of LET y)
    let num_100 = safe_new(5, 100)
    ast_child(let_y, num_100)
    
    // --- –ó–ê–ü–£–°–ö –û–ë–•–û–î–ê ---
    print(777777) // WALK START
    walk(root, 0)
    print(666666) // DONE
}

```

### üß™ –ö–∞–∫ —ç—Ç–æ —á–∏—Ç–∞—Ç—å (Output Decoding)

–ü–æ—Å–∫–æ–ª—å–∫—É —É –Ω–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–≥–æ `printf` –¥–ª—è —Å—Ç—Ä–æ–∫, –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —á–∏—Å–ª–æ–≤—ã–µ –∫–æ–¥—ã. –ï—Å–ª–∏ –≤—Å—ë —Å—Ä–∞–±–æ—Ç–∞–µ—Ç, –≤—ã–≤–æ–¥ –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å –ø—Ä–∏–º–µ—Ä–Ω–æ —Ç–∞–∫:

```
> 888888         (Start)
> 777777         (Walk Start)
> 0              (Depth 0)
> 2              (Type: NODE_FN)
> 1000           (Val: "main")
> 1111           (Depth 1)
> 3              (Type: NODE_BLOCK)
> 0              (Val: 0)
> 2222           (Depth 2)
> 4              (Type: NODE_LET)
> 120            (Val: 'x')
> 3333           (Depth 3)
> 5              (Type: NODE_NUM)
> 42             (Val: 42)
> 2222           (Depth 2 - –≤–µ—Ä–Ω—É–ª–∏—Å—å –∫ —Å–æ—Å–µ–¥—É x)
> 4              (Type: NODE_LET)
> 121            (Val: 'y')
> 3333           (Depth 3)
> 5              (Type: NODE_NUM)
> 100            (Val: 100)
> 666666         (Done)

```

### ‚ö° –¢–≤–æ—è –∑–∞–¥–∞—á–∞ (Next Step)

1. –°–∫–æ–ø–∏—Ä—É–π —ç—Ç–æ—Ç –∫–æ–¥ –≤ `examples/debug_ast.syn`.
2. –°–∫–æ–º–ø–∏–ª–∏—Ä—É–π –∏ –∑–∞–ø—É—Å—Ç–∏: `synapse.exe examples/debug_ast.syn`.
3. **–ü—Ä–∏—à–ª–∏ –º–Ω–µ –ª–æ–≥ –≤—ã–≤–æ–¥–∞.**

–ï—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–µ—Ä–µ–≤–∞ (–æ—Ç—Å—Ç—É–ø—ã –∏ —Ç–∏–ø—ã) —Å–æ–≤–ø–∞–¥–µ—Ç —Å –æ–∂–∏–¥–∞–Ω–∏—è–º–∏ ‚Äî –º—ã –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ —Å–æ–∑–¥–∞–ª–∏ **Data Structures** –≤–Ω—É—Ç—Ä–∏ SYNAPSE. –ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –º—ã –ø–æ–¥–∫–ª—é—á–∏–º –∫ —ç—Ç–æ–º—É `self_lexer` –∏ –ø–æ–ª—É—á–∏–º –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–µ—Ä.

–í–ø–µ—Ä–µ–¥, –∫ —Å–∞–º–æ—Ö–æ—Å—Ç–∏–Ω–≥—É! üöÄ

–≠—Ç–æ —Ç—Ä–∏—É–º—Ñ. **Phase 30** –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –±–µ–∑—É–ø—Ä–µ—á–Ω–æ.
–¢—ã —Ç–æ–ª—å–∫–æ —á—Ç–æ –¥–æ–∫–∞–∑–∞–ª, —á—Ç–æ SYNAPSE –º–æ–∂–µ—Ç —É–¥–µ—Ä–∂–∏–≤–∞—Ç—å –≤ —Å–≤–æ–µ–π –ø–∞–º—è—Ç–∏ —Å–ª–æ–∂–Ω—ã–µ –∏–µ—Ä–∞—Ä—Ö–∏—á–µ—Å–∫–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –∏–º —Å–∞–º–∏–º.

–¢–µ–ø–µ—Ä—å –Ω–∞—Å—Ç—É–ø–∞–µ—Ç –º–æ–º–µ–Ω—Ç –∏—Å—Ç–∏–Ω—ã. –ú—ã –¥–æ–ª–∂–Ω—ã —Å–æ–µ–¥–∏–Ω–∏—Ç—å **"–ì–ª–∞–∑–∞"** (–õ–µ–∫—Å–µ—Ä) –∏ **"–ü–∞–º—è—Ç—å"** (AST).

### üöÄ Phase 31: The Synthetic Brain (Parser)

–î–æ —ç—Ç–æ–≥–æ –º–æ–º–µ–Ω—Ç–∞ –õ–µ–∫—Å–µ—Ä –ø—Ä–æ—Å—Ç–æ *–ø–µ—á–∞—Ç–∞–ª* —Ç–æ–∫–µ–Ω—ã –Ω–∞ —ç–∫—Ä–∞–Ω. AST-–±–∏–ª–¥–µ—Ä —Å—Ç—Ä–æ–∏–ª –¥–µ—Ä–µ–≤–æ *–≤—Ä—É—á–Ω—É—é*.
–¢–µ–ø–µ—Ä—å –º—ã —Å–æ–∑–¥–∞–¥–∏–º **–ü–∞—Ä—Å–µ—Ä**.

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ Phase 31:**

1. **Token Buffer:** –õ–µ–∫—Å–µ—Ä –±–æ–ª—å—à–µ –Ω–µ –ø–µ—á–∞—Ç–∞–µ—Ç. –û–Ω —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–æ–∫–µ–Ω—ã –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã `tokens_type[]` –∏ `tokens_val[]`.
2. **Parser:** –ß–∏—Ç–∞–µ—Ç —ç—Ç–æ—Ç –±—É—Ñ–µ—Ä, –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –≥—Ä–∞–º–º–∞—Ç–∏–∫—É –∏ –≤—ã–∑—ã–≤–∞–µ—Ç `ast_new()`.
3. **AST Walker:** –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç.

–°–æ–∑–¥–∞–π —Ñ–∞–π–ª `self_parser_v1.syn`. –≠—Ç–æ –±—É–¥–µ—Ç –ø–µ—Ä–≤—ã–π —Å–∫—Ä–∏–ø—Ç, –∫–æ—Ç–æ—Ä—ã–π **—á–∏—Ç–∞–µ—Ç –∫–æ–¥ –∏ –ø–æ–Ω–∏–º–∞–µ—Ç –µ–≥–æ —Å—Ç—Ä—É–∫—Ç—É—Ä—É**.

### üìú `self_parser_v1.syn`

```synapse
// ============================================================
// SYNAPSE SELF-HOSTED PARSER V1 (Phase 31)
// ============================================================

// --- 1. CONSTANTS ---
// AST Types
let NODE_PROG  = 1
let NODE_FN    = 2
let NODE_BLOCK = 3
let NODE_LET   = 4
let NODE_NUM   = 5

// Token Types (—Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–æ —Å –ª–µ–∫—Å–µ—Ä–æ–º)
let TOK_EOF    = 0
let TOK_FN     = 1
let TOK_ID     = 2  // Identifier
let TOK_NUM    = 3  // Number
let TOK_LBRACE = 4  // {
let TOK_RBRACE = 5  // }
let TOK_LET    = 6
let TOK_EQ     = 7  // =

// --- 2. GLOBAL MEMORY ---

// AST Arena (32 –±–∞–π—Ç–∞ –Ω–∞ —É–∑–µ–ª)
let ast_arena = alloc(4000)
let ast_ptr = ast_arena

// Token Buffer (–•—Ä–∞–Ω–∏–ª–∏—â–µ —Ç–æ–∫–µ–Ω–æ–≤)
// –í–º–µ—Å—Ç–æ —Å–ª–æ–∂–Ω–æ–≥–æ –ª–µ–∫—Å–µ—Ä–∞, –¥–ª—è —Ç–µ—Å—Ç–∞ V1 –º—ã –∑–∞–ø–æ–ª–Ω–∏–º –µ–≥–æ –≤—Ä—É—á–Ω—É—é,
// —ç–º—É–ª–∏—Ä—É—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–±–æ—Ç—ã –ª–µ–∫—Å–µ—Ä–∞ –Ω–∞–¥ —Å—Ç—Ä–æ–∫–æ–π:
// "fn main { let x = 55 }"
let max_tokens = 100
let g_types = alloc(100)  // –¢–∏–ø—ã —Ç–æ–∫–µ–Ω–æ–≤
let g_vals  = alloc(100)  // –ó–Ω–∞—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–æ–≤
let g_cursor = 0          // –¢–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è –ø–∞—Ä—Å–µ—Ä–∞

// --- 3. AST ENGINE (–ò–∑ Phase 30) ---

fn ast_new(type, val) {
    let node = ast_ptr
    node[0] = type
    node[1] = val
    node[2] = 0 // Child
    node[3] = 0 // Sibling
    // –°–¥–≤–∏–≥ –Ω–∞ 4 qwords (32 –±–∞–π—Ç–∞) - —ç–º—É–ª—è—Ü–∏—è —á–µ—Ä–µ–∑ alloc –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    ast_ptr = alloc(4) 
    return node
}

fn ast_child(parent, child) {
    parent[2] = child
}

fn ast_sibling(node, next) {
    node[3] = next
}

// --- 4. PARSER LOGIC (The Brain) ---

// –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π —Ç–∏–ø —Ç–æ–∫–µ–Ω–∞
fn peek() {
    return g_types[g_cursor]
}

// –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
fn peek_val() {
    return g_vals[g_cursor]
}

// –ü–æ–≥–ª–æ—Ç–∏—Ç—å —Ç–æ–∫–µ–Ω (–ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–∏–ø –∏ —Å–¥–≤–∏–Ω—É—Ç—å –∫—É—Ä—Å–æ—Ä)
fn eat(type) {
    let cur = peek()
    if cur == type {
        g_cursor = g_cursor + 1
        return 1
    }
    // –û—à–∏–±–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
    print(999999) // ERROR MARKER
    print(type)   // –û–∂–∏–¥–∞–ª–æ—Å—å
    print(cur)    // –ü–æ–ª—É—á–µ–Ω–æ
    return 0
}

// –ü–∞—Ä—Å–∏–Ω–≥ –≤—ã—Ä–∞–∂–µ–Ω–∏—è (–ø–æ–∫–∞ —Ç–æ–ª—å–∫–æ —á–∏—Å–ª–∞)
fn parse_expr() {
    let val = peek_val()
    eat(TOK_NUM)
    return ast_new(NODE_NUM, val)
}

// –ü–∞—Ä—Å–∏–Ω–≥ let: "let x = 55"
fn parse_let() {
    eat(TOK_LET) // –°—ä–µ–ª–∏ 'let'
    
    let name = peek_val()
    eat(TOK_ID)  // –°—ä–µ–ª–∏ –∏–º—è
    
    eat(TOK_EQ)  // –°—ä–µ–ª–∏ '='
    
    let expr = parse_expr() // –ü–∞—Ä—Å–∏–º —á–∏—Å–ª–æ
    
    let node = ast_new(NODE_LET, name)
    ast_child(node, expr)
    
    return node
}

// –ü–∞—Ä—Å–∏–Ω–≥ —Å—Ç–µ–π—Ç–º–µ–Ω—Ç–∞
fn parse_stmt() {
    let t = peek()
    if t == TOK_LET {
        return parse_let()
    }
    return 0
}

// –ü–∞—Ä—Å–∏–Ω–≥ –±–ª–æ–∫–∞: "{ stmt... }"
fn parse_block() {
    eat(TOK_LBRACE)
    
    let block_node = ast_new(NODE_BLOCK, 0)
    
    // –ü–∞—Ä—Å–∏–º –ø–µ—Ä–≤—ã–π —Å—Ç–µ–π—Ç–º–µ–Ω—Ç
    let first_stmt = parse_stmt()
    ast_child(block_node, first_stmt)
    
    // (–í V1 –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ 1 —Å—Ç–µ–π—Ç–º–µ–Ω—Ç –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã)
    
    eat(TOK_RBRACE)
    return block_node
}

// –ü–∞—Ä—Å–∏–Ω–≥ —Ñ—É–Ω–∫—Ü–∏–∏: "fn name { body }"
fn parse_fn() {
    eat(TOK_FN)
    
    let name = peek_val()
    eat(TOK_ID)
    
    // (–ü—Ä–æ–ø—É—Å–∫–∞–µ–º () –¥–ª—è V1 –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è, —Å—Ä–∞–∑—É –±–ª–æ–∫)
    
    let body = parse_block()
    
    let func_node = ast_new(NODE_FN, name)
    ast_child(func_node, body)
    
    return func_node
}

// --- 5. VISUALIZER ---

fn walk(node, depth) {
    if node == 0 { return 0 }
    let indent = depth * 1111
    print(indent)
    print(node[0]) // TYPE
    print(node[1]) // VALUE
    
    let child = node[2]
    if child != 0 { walk(child, depth + 1) }
    
    let sibling = node[3]
    if sibling != 0 { walk(sibling, depth) }
}

// --- 6. MAIN ---

fn main() {
    // 1. –≠–ú–£–õ–Ø–¶–ò–Ø –õ–ï–ö–°–ï–†–ê (–ó–∞–ø–æ–ª–Ω—è–µ–º –±—É—Ñ–µ—Ä)
    // –ö–æ–¥: fn main { let x = 55 }
    
    // –¢–æ–∫–µ–Ω 0: fn
    g_types[0] = TOK_FN
    g_vals[0]  = 0
    
    // –¢–æ–∫–µ–Ω 1: main (ID)
    g_types[1] = TOK_ID
    g_vals[1]  = 1000 // 'main'
    
    // –¢–æ–∫–µ–Ω 2: {
    g_types[2] = TOK_LBRACE
    g_vals[2]  = 0
    
    // –¢–æ–∫–µ–Ω 3: let
    g_types[3] = TOK_LET
    g_vals[3]  = 0
    
    // –¢–æ–∫–µ–Ω 4: x (ID)
    g_types[4] = TOK_ID
    g_vals[4]  = 120 // 'x'
    
    // –¢–æ–∫–µ–Ω 5: =
    g_types[5] = TOK_EQ
    g_vals[5]  = 0
    
    // –¢–æ–∫–µ–Ω 6: 55 (NUM)
    g_types[6] = TOK_NUM
    g_vals[6]  = 55
    
    // –¢–æ–∫–µ–Ω 7: }
    g_types[7] = TOK_RBRACE
    g_vals[7]  = 0
    
    print(111111) // PARSE START
    
    // 2. –ó–ê–ü–£–°–ö –ü–ê–†–°–ï–†–ê
    let root = parse_fn()
    
    print(222222) // PARSE DONE
    
    // 3. –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø
    walk(root, 0)
    
    print(333333) // FINISHED
}

```

### üß† –ß—Ç–æ –∑–¥–µ—Å—å –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç?

1. **–≠–º—É–ª—è—Ü–∏—è –õ–µ–∫—Å–µ—Ä–∞:** –ú—ã –≤—Ä—É—á–Ω—É—é –∑–∞–ø–æ–ª–Ω—è–µ–º –º–∞—Å—Å–∏–≤—ã `g_types` –∏ `g_vals`, –∫–∞–∫ –µ—Å–ª–∏ –±—ã –ª–µ–∫—Å–µ—Ä –ø—Ä–æ—á–∏—Ç–∞–ª —Å—Ç—Ä–æ–∫—É `fn main { let x = 55 }`.
2. **–†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π —Å–ø—É—Å–∫:** –§—É–Ω–∫—Ü–∏–∏ `parse_fn` -> `parse_block` -> `parse_stmt` -> `parse_let` –≤—ã–∑—ã–≤–∞—é—Ç –¥—Ä—É–≥ –¥—Ä—É–≥–∞.
3. **–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤–∞:** –ö–∞–∂–¥–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–∞—Ä—Å–∏–Ω–≥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —É–∑–µ–ª, –∫–æ—Ç–æ—Ä—ã–π –æ–Ω–∞ —Å–æ–∑–¥–∞–ª–∞.
4. **–°–≤—è–∑—ã–≤–∞–Ω–∏–µ:** `parse_fn` –±–µ—Ä–µ—Ç —É–∑–µ–ª –æ—Ç `parse_block` –∏ –¥–µ–ª–∞–µ—Ç –µ–≥–æ —Å–≤–æ–∏–º —Ä–µ–±–µ–Ω–∫–æ–º (`ast_child`).

### üß™ –û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç

```
> 111111    (Start Parse)
> 222222    (End Parse)
> 0         (Depth 0)
> 2         (Type: NODE_FN)
> 1000      (Value: main)
> 1111      (Depth 1)
> 3         (Type: NODE_BLOCK)
> 0
> 2222      (Depth 2)
> 4         (Type: NODE_LET)
> 120       (Value: x)
> 3333      (Depth 3)
> 5         (Type: NODE_NUM)
> 55        (Value: 55)
> 333333    (Finished)

```

**–ó–∞–¥–∞—á–∞:**

1. –ó–∞–ø—É—Å—Ç–∏ `self_parser_v1.syn`.
2. –ï—Å–ª–∏ –≤—ã–≤–æ–¥ —Å–æ–≤–ø–∞–¥–µ—Ç ‚Äî –º—ã —Å–æ–∑–¥–∞–ª–∏ **–ø–µ—Ä–≤—ã–π —Ä–∞–±–æ—Ç–∞—é—â–∏–π –ø–∞—Ä—Å–µ—Ä –Ω–∞ SYNAPSE**.

–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ —à–∞–≥–∞ –º—ã –ø–æ–¥–∫–ª—é—á–∏–º —Ä–µ–∞–ª—å–Ω—ã–π –ª–µ–∫—Å–µ—Ä (Phase 32) –∏ –∑–∞–º–∫–Ω–µ–º –∫—Ä—É–≥. –î–µ–π—Å—Ç–≤—É–π!
–≠—Ç–æ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–π –º–æ–º–µ–Ω—Ç. –ú—ã –±–æ–ª—å—à–µ –Ω–µ —ç–º—É–ª–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ.
**Phase 31** –¥–æ–∫–∞–∑–∞–ª–∞, —á—Ç–æ "–ú–æ–∑–≥" —Ä–∞–±–æ—Ç–∞–µ—Ç.
–¢–µ–ø–µ—Ä—å –ø–æ–¥–∫–ª—é—á–∞–µ–º –∫ –Ω–µ–º—É "–ì–ª–∞–∑–∞".

### üöÄ Phase 32: The Grand Unification (Lexer + Parser)

–í —ç—Ç–æ–º —Å–∫—Ä–∏–ø—Ç–µ –º—ã –æ–±—ä–µ–¥–∏–Ω—è–µ–º –Ω–∞—Ä–∞–±–æ—Ç–∫–∏ `self_lexer` (Phase 29) –∏ `self_parser` (Phase 31).

**–ß—Ç–æ –º–µ–Ω—è–µ—Ç—Å—è:**

1. **Source Memory:** –ú—ã —Å–æ–∑–¥–∞–µ–º —Å—Ç—Ä–æ–∫—É –∫–æ–¥–∞ –≤ –ø–∞–º—è—Ç–∏ (–∏–º–∏—Ç–∞—Ü–∏—è —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞).
2. **Real Lexer:** –§—É–Ω–∫—Ü–∏—è `lex()` –±–µ–∂–∏—Ç –ø–æ –±–∞–π—Ç–∞–º —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏ –∏ **—Å–∞–º–∞** –∑–∞–ø–æ–ª–Ω—è–µ—Ç `g_types` –∏ `g_vals`.
3. **Parser:** –†–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ —Ä–∞–Ω—å—à–µ, –Ω–æ —Ç–µ–ø–µ—Ä—å –æ–Ω –ø–æ—Ç—Ä–µ–±–ª—è–µ—Ç —Ç–æ, —á—Ç–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–ª –ª–µ–∫—Å–µ—Ä.

–°–æ–∑–¥–∞–π —Ñ–∞–π–ª `self_parser_v2.syn`. –≠—Ç–æ –ø–µ—Ä–≤—ã–π **–ø–æ–ª–Ω—ã–π –∫–æ–Ω–≤–µ–π–µ—Ä**.

### üìú `self_parser_v2.syn`

```synapse
// ============================================================
// SYNAPSE SELF-HOSTED COMPILER V2 (Phase 32)
// Lexer + Parser Integration
// ============================================================

// --- 1. CONSTANTS ---
// AST Types
let NODE_PROG  = 1
let NODE_FN    = 2
let NODE_BLOCK = 3
let NODE_LET   = 4
let NODE_NUM   = 5

// Token Types
let TOK_EOF    = 0
let TOK_FN     = 1
let TOK_ID     = 2
let TOK_NUM    = 3
let TOK_LBRACE = 4
let TOK_RBRACE = 5
let TOK_LET    = 6
let TOK_EQ     = 7

// ASCII Codes
let CHAR_SPACE = 32
let CHAR_f     = 102
let CHAR_n     = 110
let CHAR_l     = 108
let CHAR_e     = 101
let CHAR_t     = 116
let CHAR_LBR   = 123 // {
let CHAR_RBR   = 125 // }
let CHAR_EQ    = 61  // =

// --- 2. GLOBAL MEMORY ---

// AST Arena
let ast_arena = alloc(4000)
let ast_ptr = ast_arena

// Token Buffer (–ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫–∞–Ω–∞–ª —Å–≤—è–∑–∏ Lexer -> Parser)
let g_types = alloc(100)
let g_vals  = alloc(100)
let g_tok_count = 0
let g_cursor = 0   // –ü–æ–∑–∏—Ü–∏—è –ø–∞—Ä—Å–µ—Ä–∞

// Source Code Buffer (–ë–∞–π—Ç–æ–≤—ã–π –º–∞—Å—Å–∏–≤)
let src_len = 100
let src_ptr = alloc_bytes(100) 

// --- 3. HELPER FUNCTIONS ---

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ –≤ –ø–∞–º—è—Ç–∏
// –ö–æ–¥: "fn main { let x = 55 }"
fn init_source() {
    let p = src_ptr
    // fn
    set_byte(p, 0, 102) // f
    set_byte(p, 1, 110) // n
    set_byte(p, 2, 32)  // space
    // main (—É–ø—Ä–æ—Å—Ç–∏–º –¥–æ 1 –±—É–∫–≤—ã 'm' –¥–ª—è —Ç–µ—Å—Ç–∞ –ª–µ–∫—Å–µ—Ä–∞)
    set_byte(p, 3, 109) // m
    set_byte(p, 4, 32)  // space
    // {
    set_byte(p, 5, 123) // {
    set_byte(p, 6, 32)  // space
    // let
    set_byte(p, 7, 108) // l
    set_byte(p, 8, 101) // e
    set_byte(p, 9, 116) // t
    set_byte(p, 10, 32) // space
    // x
    set_byte(p, 11, 120) // x
    set_byte(p, 12, 32)  // space
    // =
    set_byte(p, 13, 61)  // =
    set_byte(p, 14, 32)  // space
    // 55
    set_byte(p, 15, 53)  // 5
    set_byte(p, 16, 53)  // 5
    set_byte(p, 17, 32)  // space
    // }
    set_byte(p, 18, 125) // }
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–ª–∏–Ω—É (19 —Å–∏–º–≤–æ–ª–æ–≤)
    src_len = 19
}

fn is_digit(c) {
    if c < 48 { return 0 }
    if c > 57 { return 0 }
    return 1
}

fn emit_token(type, val) {
    let idx = g_tok_count
    g_types[idx] = type
    g_vals[idx]  = val
    g_tok_count = g_tok_count + 1
}

// --- 4. THE LEXER (The Eyes) ---

fn lex() {
    let i = 0
    let c = 0
    let next_c = 0
    
    while i < src_len {
        c = get_byte(src_ptr, i)
        
        // Skip Space
        if c == 32 { 
            i = i + 1
            // continue –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ v2.9, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É if/else
        } else {
        
            // Check 'fn'
            if c == CHAR_f {
                next_c = get_byte(src_ptr, i + 1)
                if next_c == CHAR_n {
                    emit_token(TOK_FN, 0)
                    i = i + 2
                    // goto skip_loop - —ç–º—É–ª—è—Ü–∏—è continue
                    c = 0 // —Ñ–ª–∞–≥ "–æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ"
                }
            }
            
            // Check 'let' (–µ—Å–ª–∏ c –µ—â–µ –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω)
            if c == CHAR_l {
                next_c = get_byte(src_ptr, i + 1)
                if next_c == CHAR_e {
                    emit_token(TOK_LET, 0)
                    i = i + 3 // l, e, t
                    c = 0
                }
            }
            
            // Check '{'
            if c == CHAR_LBR {
                emit_token(TOK_LBRACE, 0)
                i = i + 1
                c = 0
            }
            
            // Check '}'
            if c == CHAR_RBR {
                emit_token(TOK_RBRACE, 0)
                i = i + 1
                c = 0
            }
            
            // Check '='
            if c == CHAR_EQ {
                emit_token(TOK_EQ, 0)
                i = i + 1
                c = 0
            }
            
            // Check Identifier (Single char for now: 'm', 'x')
            // –ï—Å–ª–∏ —Å != 0 (–∑–Ω–∞—á–∏—Ç –Ω–µ —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª –≤—ã—à–µ) –∏ > 96 ('a'..)
            if c > 96 {
                emit_token(TOK_ID, c)
                i = i + 1
                c = 0
            }
            
            // Check Number
            if is_digit(c) == 1 {
                let num = c - 48
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ª–µ–¥—É—é—â—É—é —Ü–∏—Ñ—Ä—É (–ø—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–∏–Ω–≥ 2 –∑–Ω–∞–∫–æ–≤)
                next_c = get_byte(src_ptr, i + 1)
                if is_digit(next_c) == 1 {
                    num = num * 10
                    num = num + (next_c - 48)
                    i = i + 2
                } else {
                    i = i + 1
                }
                emit_token(TOK_NUM, num)
                c = 0
            }
        }
    }
}

// --- 5. AST ENGINE ---

fn ast_new(type, val) {
    let node = ast_ptr
    node[0] = type
    node[1] = val
    node[2] = 0
    node[3] = 0
    ast_ptr = alloc(4) 
    return node
}

fn ast_child(parent, child) {
    parent[2] = child
}

// --- 6. PARSER LOGIC (The Brain) ---

fn peek() { return g_types[g_cursor] }
fn peek_val() { return g_vals[g_cursor] }

fn eat(type) {
    let cur = peek()
    if cur == type {
        g_cursor = g_cursor + 1
        return 1
    }
    print(999999) // ERROR
    return 0
}

fn parse_expr() {
    let val = peek_val()
    eat(TOK_NUM)
    return ast_new(NODE_NUM, val)
}

fn parse_let() {
    eat(TOK_LET)
    let name = peek_val()
    eat(TOK_ID)
    eat(TOK_EQ)
    let expr = parse_expr()
    let node = ast_new(NODE_LET, name)
    ast_child(node, expr)
    return node
}

fn parse_stmt() {
    let t = peek()
    if t == TOK_LET { return parse_let() }
    return 0
}

fn parse_block() {
    eat(TOK_LBRACE)
    let block_node = ast_new(NODE_BLOCK, 0)
    let first_stmt = parse_stmt()
    ast_child(block_node, first_stmt)
    eat(TOK_RBRACE)
    return block_node
}

fn parse_fn() {
    eat(TOK_FN)
    let name = peek_val()
    eat(TOK_ID)
    let body = parse_block()
    let func_node = ast_new(NODE_FN, name)
    ast_child(func_node, body)
    return func_node
}

// --- 7. VISUALIZER ---

fn walk(node, depth) {
    if node == 0 { return 0 }
    let indent = depth * 1111
    print(indent)
    print(node[0]) // TYPE
    print(node[1]) // VALUE
    
    let child = node[2]
    if child != 0 { walk(child, depth + 1) }
    
    let sibling = node[3]
    if sibling != 0 { walk(sibling, depth) }
}

// --- 8. MAIN ---

fn main() {
    print(100000) // INIT
    
    // 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º "—Ñ–∞–π–ª" –≤ –ø–∞–º—è—Ç–∏
    init_source()
    
    print(200000) // LEXING START
    
    // 2. –ó–∞–ø—É—Å–∫–∞–µ–º –ª–µ–∫—Å–µ—Ä (–∑–∞–ø–æ–ª–Ω—è–µ—Ç g_types/g_vals)
    lex()
    
    print(g_tok_count) // –°–∫–æ–ª—å–∫–æ —Ç–æ–∫–µ–Ω–æ–≤ –Ω–∞—à–ª–∏? (–û–∂–∏–¥–∞–µ–º 8)
    print(300000) // PARSING START
    
    // 3. –ó–∞–ø—É—Å–∫–∞–µ–º –ø–∞—Ä—Å–µ—Ä
    let root = parse_fn()
    
    print(400000) // AST READY
    
    // 4. –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º
    walk(root, 0)
}

```

### üõ† –ß—Ç–æ –¥–µ–ª–∞–µ—Ç —ç—Ç–æ—Ç –∫–æ–¥?

1. **`init_source()`**: –ó–∞–ø–∏—Å—ã–≤–∞–µ—Ç –±–∞–π—Ç—ã `f`, `n`, `     `, `m`, ... –ø—Ä—è–º–æ –≤ –ø–∞–º—è—Ç—å –∫—É—á–∏, –∏–º–∏—Ç–∏—Ä—É—è –∑–∞–≥—Ä—É–∑–∫—É —Ñ–∞–π–ª–∞.
2. **`lex()`**: –ß–∏—Ç–∞–µ—Ç —ç—Ç–∏ –±–∞–π—Ç—ã, —Ä–∞—Å–ø–æ–∑–Ω–∞–µ—Ç –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ (`fn`, `let`) –∏ —Å–∏–º–≤–æ–ª—ã, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∏—Ö –≤ —Ç–æ–∫–µ–Ω—ã –≤ `g_types`.
3. **`parse_fn()`**: –ß–∏—Ç–∞–µ—Ç —Ç–æ–∫–µ–Ω—ã –∏ —Å—Ç—Ä–æ–∏—Ç –¥–µ—Ä–µ–≤–æ.
4. **`walk()`**: –í—ã–≤–æ–¥–∏—Ç –¥–µ—Ä–µ–≤–æ.

### üß™ –û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥

–ï—Å–ª–∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞, —Ç—ã —É–≤–∏–¥–∏—à—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ñ–∞–∑:

1. `100000` (Init)
2. `200000` (Lexing)
3. `8` (–ù–∞–π–¥–µ–Ω–æ 8 —Ç–æ–∫–µ–Ω–æ–≤)
4. `300000` (Parsing)
5. `400000` (AST Ready)
6. –î–∞–ª–µ–µ —Å–∞–º–æ –¥–µ—Ä–µ–≤–æ AST (–∫–∞–∫ –≤ –ø—Ä–æ—à–ª—ã–π —Ä–∞–∑).

**–ó–∞–ø—É—Å–∫–∞–π `synapse.exe self_parser_v2.syn`!** –ï—Å–ª–∏ —ç—Ç–æ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç, SYNAPSE –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ —Å—Ç–∞–ª **Self-Hosting Compiler Front-End**.
–≠—Ç–æ –º–æ–Ω—É–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π —É—Å–ø–µ—Ö. **Phase 32** –∑–∞–≤–µ—Ä—à–µ–Ω–∞.
SYNAPSE —Ç–µ–ø–µ—Ä—å –æ–±–ª–∞–¥–∞–µ—Ç –ø–æ–ª–Ω—ã–º —Å–æ–∑–Ω–∞–Ω–∏–µ–º: –æ–Ω –≤–∏–¥–∏—Ç –∫–æ–¥ (Lexer), –ø–æ–Ω–∏–º–∞–µ—Ç –µ–≥–æ —Å–º—ã—Å–ª (Parser) –∏ —Ö—Ä–∞–Ω–∏—Ç –µ–≥–æ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≤ –ø–∞–º—è—Ç–∏ (AST).

–¢–µ–ø–µ—Ä—å –º—ã –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–∞–º–æ–º—É —Å–≤—è—â–µ–Ω–Ω–æ–º—É —ç—Ç–∞–ø—É. –ú—ã –Ω–∞—É—á–∏–º SYNAPSE –≥–æ–≤–æ—Ä–∏—Ç—å –Ω–∞ —è–∑—ã–∫–µ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞.

### üöÄ Phase 33: The Voice (Code Generation)

**–ó–∞–¥–∞—á–∞:** –ü—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å –¥–µ—Ä–µ–≤–æ AST –≤ –º–∞—Å—Å–∏–≤ –±–∞–π—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä x64 —Å–º–æ–∂–µ—Ç –∏—Å–ø–æ–ª–Ω–∏—Ç—å.

‚ö†Ô∏è **–í–∞–∂–Ω–æ–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ:**
–ü–∞–º—è—Ç—å, –∫–æ—Ç–æ—Ä—É—é –º—ã –ø–æ–ª—É—á–∞–µ–º —á–µ—Ä–µ–∑ `alloc()`, –∏–º–µ–µ—Ç –ø—Ä–∞–≤–∞ `READ | WRITE`. –û–Ω–∞ **–Ω–µ –∏—Å–ø–æ–ª–Ω—è–µ–º–∞—è** (NX bit). –ü–æ—ç—Ç–æ–º—É –≤ Phase 33 –º—ã –±—É–¥–µ–º *–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å* –º–∞—à–∏–Ω–Ω—ã–π –∫–æ–¥ –≤ –±—É—Ñ–µ—Ä –∏ –≤—ã–≤–æ–¥–∏—Ç—å –µ–≥–æ –Ω–∞ —ç–∫—Ä–∞–Ω –≤ –≤–∏–¥–µ HEX-–¥–∞–º–ø–∞.
–ú—ã –¥–æ–ª–∂–Ω—ã —É–≤–∏–¥–µ—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –æ–ø–∫–æ–¥—ã x64.

**–¶–µ–ª—å:** –°–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é `fn main { return 42 }`.

–û–∂–∏–¥–∞–µ–º—ã–π –º–∞—à–∏–Ω–Ω—ã–π –∫–æ–¥ (x64 System V / Windows):

1. **–ü—Ä–æ–ª–æ–≥:** `55 48 89 E5` (PUSH RBP; MOV RBP, RSP)
2. **–¢–µ–ª–æ:** `48 B8 2A 00 ...` (MOV RAX, 42)
3. **–≠–ø–∏–ª–æ–≥:** `5D C3` (POP RBP; RET)

–°–æ–∑–¥–∞–π —Ñ–∞–π–ª `self_codegen_v1.syn`.

### üìú `self_codegen_v1.syn`

```synapse
// ============================================================
// SYNAPSE SELF-HOSTED CODEGEN V1 (Phase 33)
// AST -> x64 Machine Code
// ============================================================

// --- 1. CONSTANTS ---
let NODE_PROG  = 1
let NODE_FN    = 2
let NODE_BLOCK = 3
let NODE_LET   = 4
let NODE_NUM   = 5
let NODE_RET   = 7 // Return node

// x64 Opcodes
let OP_PUSH_RBP = 85  // 0x55
let OP_MOV_RBP  = 72  // 0x48 0x89 0xE5 (Prefix)
let OP_MOV_RAX  = 184 // 0xB8 (MOV RAX, imm64) - part of 48 B8...
let OP_POP_RBP  = 93  // 0x5D
let OP_RET      = 195 // 0xC3

// --- 2. GLOBAL MEMORY ---
// AST Arena
let ast_arena = alloc(4000)
let ast_ptr = ast_arena

// Code Buffer (–ö—É–¥–∞ –ø–∏—à–µ–º –º–∞—à–∏–Ω–Ω—ã–π –∫–æ–¥)
let code_buf = alloc_bytes(1024)
let code_cursor = 0

// --- 3. AST BUILDER (–£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –¥–ª—è —Ç–µ—Å—Ç–∞) ---
fn ast_new(type, val) {
    let node = ast_ptr
    node[0] = type
    node[1] = val
    node[2] = 0 // Child
    node[3] = 0 // Sibling
    ast_ptr = alloc(4) 
    return node
}

fn ast_child(parent, child) { parent[2] = child }

// --- 4. CODE EMITTER (–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ë–∞–π—Ç–æ–≤) ---

// –ó–∞–ø–∏—Å–∞—Ç—å 1 –±–∞–π—Ç
fn emit(byte_val) {
    set_byte(code_buf, code_cursor, byte_val)
    code_cursor = code_cursor + 1
}

// –ó–∞–ø–∏—Å–∞—Ç—å 8 –±–∞–π—Ç (64-bit —á–∏—Å–ª–æ, little-endian)
fn emit64(val) {
    // –í v2.9 —É –Ω–∞—Å –Ω–µ—Ç —Å–¥–≤–∏–≥–æ–≤ (>>), –Ω–æ –µ—Å—Ç—å –¥–µ–ª–µ–Ω–∏–µ/—É–º–Ω–æ–∂–µ–Ω–∏–µ
    // –≠–º—É–ª—è—Ü–∏—è —Å–¥–≤–∏–≥–æ–≤ —á–µ—Ä–µ–∑ –º–∞—Ç–µ–º–∞—Ç–∏–∫—É –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –±–∞–π—Ç–æ–≤
    
    // Byte 0
    let b = val % 256
    emit(b)
    val = val / 256 // shift right 8
    
    // Byte 1
    b = val % 256
    emit(b)
    val = val / 256
    
    // Byte 2
    b = val % 256
    emit(b)
    val = val / 256
    
    // Byte 3
    b = val % 256
    emit(b)
    val = val / 256
    
    // Bytes 4-7 (–¥–ª—è –º–∞–ª—ã—Ö —á–∏—Å–µ–ª –±—É–¥—É—Ç 0)
    emit(0)
    emit(0)
    emit(0)
    emit(0)
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ü—Ä–æ–ª–æ–≥–∞ —Ñ—É–Ω–∫—Ü–∏–∏
fn gen_prologue() {
    // PUSH RBP (0x55)
    emit(85)
    
    // MOV RBP, RSP (0x48 0x89 0xE5)
    emit(72)  // 0x48
    emit(137) // 0x89
    emit(229) // 0xE5
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≠–ø–∏–ª–æ–≥–∞ —Ñ—É–Ω–∫—Ü–∏–∏
fn gen_epilogue() {
    // POP RBP (0x5D)
    emit(93)
    
    // RET (0xC3)
    emit(195)
}

// --- 5. CODEGEN LOGIC (Traverser) ---

fn gen_num(node) {
    let val = node[1]
    
    // MOV RAX, imm64 (0x48 0xB8 + 8 bytes)
    emit(72)  // 0x48 (REX.W)
    emit(184) // 0xB8 (MOV RAX)
    emit64(val)
}

fn gen_ret(node) {
    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è –≤–æ–∑–≤—Ä–∞—Ç–∞
    let expr = node[2] // Child
    if expr[0] == NODE_NUM {
        gen_num(expr)
    }
    
    // –ü–æ—Å–ª–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ RAX
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —ç–ø–∏–ª–æ–≥ –∏ –≤—ã—Ö–æ–¥
    gen_epilogue()
}

fn gen_block(node) {
    let stmt = node[2] // Child (First statement)
    
    // –ü—Ä–æ—Å—Ç–µ–π—à–∏–π –æ–±—Ö–æ–¥ (–ø–æ–∫–∞ —Ç–æ–ª—å–∫–æ 1 —Å—Ç–µ–π—Ç–º–µ–Ω—Ç)
    if stmt != 0 {
        if stmt[0] == NODE_RET {
            gen_ret(stmt)
        }
    }
}

fn gen_fn(node) {
    gen_prologue()
    
    let body = node[2] // Child (Block)
    if body != 0 {
        gen_block(body)
    } else {
        // –ï—Å–ª–∏ —Ç–µ–ª–∞ –Ω–µ—Ç, –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—Ç
        gen_epilogue()
    }
}

// --- 6. HEX DUMPER (Verification) ---

fn print_hex() {
    let i = 0
    while i < code_cursor {
        let b = get_byte(code_buf, i)
        print(b)
        i = i + 1
    }
}

// --- 7. MAIN ---

fn main() {
    print(111111) // CODEGEN START
    
    // 1. –°—Ç—Ä–æ–∏–º AST –≤—Ä—É—á–Ω—É—é (—ç–º—É–ª—è—Ü–∏—è –ø–∞—Ä—Å–µ—Ä–∞)
    // –ö–æ–¥: fn main { return 42 }
    
    // Node: NUM 42
    let n_num = ast_new(NODE_NUM, 42)
    
    // Node: RET (child = NUM)
    let n_ret = ast_new(NODE_RET, 0)
    ast_child(n_ret, n_num)
    
    // Node: BLOCK (child = RET)
    let n_block = ast_new(NODE_BLOCK, 0)
    ast_child(n_block, n_ret)
    
    // Node: FN main (child = BLOCK)
    let n_fn = ast_new(NODE_FN, 1000)
    ast_child(n_fn, n_block)
    
    // 2. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–¥
    gen_fn(n_fn)
    
    print(222222) // GENERATED BYTES:
    
    // 3. –í—ã–≤–æ–¥–∏–º –±–∞–π—Ç—ã
    print_hex()
    
    print(333333) // DONE
}

```

### üîÆ –ö–∞–∫ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç?

–°–∫—Ä–∏–ø—Ç –≤—ã–≤–µ–¥–µ—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —á–∏—Å–µ–ª (–¥–µ—Å—è—Ç–∏—á–Ω—ã—Ö –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–π –±–∞–π—Ç–æ–≤).
–¢–µ–±–µ –Ω—É–∂–Ω–æ —Å–≤–µ—Ä–∏—Ç—å –∏—Ö —Å —ç—Ç–∞–ª–æ–Ω–æ–º x64:

| Decimal | Hex | –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è |
| --- | --- | --- |
| **85** | 55 | `PUSH RBP` |
| **72** | 48 | `REX.W` Prefix |
| **137** | 89 | `MOV` |
| **229** | E5 | `ModR/M` (RBP, RSP) |
| **72** | 48 | `REX.W` |
| **184** | B8 | `MOV RAX` |
| **42** | 2A | Low byte of 42 |
| **0** | 00 | ... |
| **0** | 00 | ... |
| **0** | 00 | ... |
| **0** | 00 | ... |
| **0** | 00 | ... |
| **0** | 00 | ... |
| **0** | 00 | High byte |
| **93** | 5D | `POP RBP` |
| **195** | C3 | `RET` |

**–ó–∞–ø—É—Å–∫–∞–π `self_codegen_v1.syn`!** –ï—Å–ª–∏ —Ü–∏—Ñ—Ä—ã —Å–æ–≤–ø–∞–¥—É—Ç, SYNAPSE –Ω–∞—É—á–∏–ª—Å—è –ø–∏—Å–∞—Ç—å –±–∏–Ω–∞—Ä–Ω—ã–π –∫–æ–¥.

