// ============================================================
// SELF-COMPILE V5: CONTROL FLOW (IF)
// Goal: Compile "if x { ... }"
// ============================================================

// --- CONSTANTS ---
let TOK_FN = 1
let TOK_ID = 2
let TOK_LBRACE = 3
let TOK_RBRACE = 4
let TOK_RET = 5
let TOK_NUM = 6
let TOK_IF = 9      // [NEW]
let TOK_LET = 60
let TOK_EQ = 61
let TOK_EOF = 99

// AST Nodes (ALIGNED)
let NODE_FN = 10
let NODE_BLOCK = 11
let NODE_RET = 12
let NODE_NUM = 13
let NODE_LET = 20
let NODE_ID = 21
let NODE_IF = 6
let NODE_WHILE = 8
let NODE_ASSIGN = 9
let NODE_ADD = 30
let NODE_SUB = 31

// State Offsets
let OFF_SRC_MEM = 0
let OFF_DATA_MEM = 8
let OFF_CODE_BUF = 16
let OFF_SRC_LEN = 24
let OFF_CODE_IDX = 32
let OFF_DATA_PTR = 40
let OFF_CODE_CURSOR = 48
let OFF_CURR_TOK = 56
let OFF_CURR_VAL = 64
let OFF_SYM_COUNT = 72
let OFF_STACK_DEPTH = 80
let OFF_SYM_PTR = 88

// --- MATH UTILS ---

fn val_div_256(val) { return val / 256 }
fn val_mod_256(val) { return val % 256 }

// FIX: Handle negative numbers for backward jumps
fn to_u8(val) {
    let v = val % 256
    if v < 0 { v = v + 256 }
    return v
}

// --- PARTITIONED WRITER ---
fn wb_0(ptr, off, val) {
    if val == 0 { set_byte(ptr, off, 0) return 1 }
    if val == 1 { set_byte(ptr, off, 1) return 1 }
    if val == 2 { set_byte(ptr, off, 2) return 1 }
    if val == 3 { set_byte(ptr, off, 3) return 1 }
    if val == 4 { set_byte(ptr, off, 4) return 1 }
    if val == 5 { set_byte(ptr, off, 5) return 1 }
    if val == 6 { set_byte(ptr, off, 6) return 1 }
    if val == 7 { set_byte(ptr, off, 7) return 1 }
    if val == 8 { set_byte(ptr, off, 8) return 1 }
    if val == 9 { set_byte(ptr, off, 9) return 1 }
    if val == 10 { set_byte(ptr, off, 10) return 1 }
    if val == 11 { set_byte(ptr, off, 11) return 1 }
    if val == 12 { set_byte(ptr, off, 12) return 1 }
    if val == 13 { set_byte(ptr, off, 13) return 1 }
    if val == 14 { set_byte(ptr, off, 14) return 1 }
    if val == 15 { set_byte(ptr, off, 15) return 1 }
    if val == 16 { set_byte(ptr, off, 16) return 1 }
    if val == 17 { set_byte(ptr, off, 17) return 1 }
    if val == 18 { set_byte(ptr, off, 18) return 1 }
    if val == 19 { set_byte(ptr, off, 19) return 1 }
    if val == 20 { set_byte(ptr, off, 20) return 1 }
    if val == 21 { set_byte(ptr, off, 21) return 1 }
    if val == 22 { set_byte(ptr, off, 22) return 1 }
    if val == 23 { set_byte(ptr, off, 23) return 1 }
    if val == 24 { set_byte(ptr, off, 24) return 1 }
    if val == 25 { set_byte(ptr, off, 25) return 1 }
    if val == 26 { set_byte(ptr, off, 26) return 1 }
    if val == 27 { set_byte(ptr, off, 27) return 1 }
    if val == 28 { set_byte(ptr, off, 28) return 1 }
    if val == 29 { set_byte(ptr, off, 29) return 1 }
    if val == 30 { set_byte(ptr, off, 30) return 1 }
    if val == 31 { set_byte(ptr, off, 31) return 1 }
    if val == 32 { set_byte(ptr, off, 32) return 1 }
    if val == 33 { set_byte(ptr, off, 33) return 1 }
    if val == 34 { set_byte(ptr, off, 34) return 1 }
    if val == 35 { set_byte(ptr, off, 35) return 1 }
    if val == 36 { set_byte(ptr, off, 36) return 1 }
    if val == 37 { set_byte(ptr, off, 37) return 1 }
    if val == 38 { set_byte(ptr, off, 38) return 1 }
    if val == 39 { set_byte(ptr, off, 39) return 1 }
    if val == 40 { set_byte(ptr, off, 40) return 1 }
    if val == 41 { set_byte(ptr, off, 41) return 1 }
    if val == 42 { set_byte(ptr, off, 42) return 1 }
    if val == 43 { set_byte(ptr, off, 43) return 1 }
    if val == 44 { set_byte(ptr, off, 44) return 1 }
    if val == 45 { set_byte(ptr, off, 45) return 1 }
    if val == 46 { set_byte(ptr, off, 46) return 1 }
    if val == 47 { set_byte(ptr, off, 47) return 1 }
    if val == 48 { set_byte(ptr, off, 48) return 1 }
    if val == 49 { set_byte(ptr, off, 49) return 1 }
    if val == 50 { set_byte(ptr, off, 50) return 1 }
    if val == 51 { set_byte(ptr, off, 51) return 1 }
    if val == 52 { set_byte(ptr, off, 52) return 1 }
    if val == 53 { set_byte(ptr, off, 53) return 1 }
    if val == 54 { set_byte(ptr, off, 54) return 1 }
    if val == 55 { set_byte(ptr, off, 55) return 1 }
    if val == 56 { set_byte(ptr, off, 56) return 1 }
    if val == 57 { set_byte(ptr, off, 57) return 1 }
    if val == 58 { set_byte(ptr, off, 58) return 1 }
    if val == 59 { set_byte(ptr, off, 59) return 1 }
    if val == 60 { set_byte(ptr, off, 60) return 1 }
    if val == 61 { set_byte(ptr, off, 61) return 1 }
    if val == 62 { set_byte(ptr, off, 62) return 1 }
    if val == 63 { set_byte(ptr, off, 63) return 1 }
    return 0
}

fn wb_1(ptr, off, val) {
    if val == 64 { set_byte(ptr, off, 64) return 1 }
    if val == 65 { set_byte(ptr, off, 65) return 1 }
    if val == 66 { set_byte(ptr, off, 66) return 1 }
    if val == 67 { set_byte(ptr, off, 67) return 1 }
    if val == 68 { set_byte(ptr, off, 68) return 1 }
    if val == 69 { set_byte(ptr, off, 69) return 1 }
    if val == 70 { set_byte(ptr, off, 70) return 1 }
    if val == 71 { set_byte(ptr, off, 71) return 1 }
    if val == 72 { set_byte(ptr, off, 72) return 1 }
    if val == 73 { set_byte(ptr, off, 73) return 1 }
    if val == 74 { set_byte(ptr, off, 74) return 1 }
    if val == 75 { set_byte(ptr, off, 75) return 1 }
    if val == 76 { set_byte(ptr, off, 76) return 1 }
    if val == 77 { set_byte(ptr, off, 77) return 1 }
    if val == 78 { set_byte(ptr, off, 78) return 1 }
    if val == 79 { set_byte(ptr, off, 79) return 1 }
    if val == 80 { set_byte(ptr, off, 80) return 1 }
    if val == 81 { set_byte(ptr, off, 81) return 1 }
    if val == 82 { set_byte(ptr, off, 82) return 1 }
    if val == 83 { set_byte(ptr, off, 83) return 1 }
    if val == 84 { set_byte(ptr, off, 84) return 1 }
    if val == 85 { set_byte(ptr, off, 85) return 1 }
    if val == 86 { set_byte(ptr, off, 86) return 1 }
    if val == 87 { set_byte(ptr, off, 87) return 1 }
    if val == 88 { set_byte(ptr, off, 88) return 1 }
    if val == 89 { set_byte(ptr, off, 89) return 1 }
    if val == 90 { set_byte(ptr, off, 90) return 1 }
    if val == 91 { set_byte(ptr, off, 91) return 1 }
    if val == 92 { set_byte(ptr, off, 92) return 1 }
    if val == 93 { set_byte(ptr, off, 93) return 1 }
    if val == 94 { set_byte(ptr, off, 94) return 1 }
    if val == 95 { set_byte(ptr, off, 95) return 1 }
    if val == 96 { set_byte(ptr, off, 96) return 1 }
    if val == 97 { set_byte(ptr, off, 97) return 1 }
    if val == 98 { set_byte(ptr, off, 98) return 1 }
    if val == 99 { set_byte(ptr, off, 99) return 1 }
    if val == 100 { set_byte(ptr, off, 100) return 1 }
    if val == 101 { set_byte(ptr, off, 101) return 1 }
    if val == 102 { set_byte(ptr, off, 102) return 1 }
    if val == 103 { set_byte(ptr, off, 103) return 1 }
    if val == 104 { set_byte(ptr, off, 104) return 1 }
    if val == 105 { set_byte(ptr, off, 105) return 1 }
    if val == 106 { set_byte(ptr, off, 106) return 1 }
    if val == 107 { set_byte(ptr, off, 107) return 1 }
    if val == 108 { set_byte(ptr, off, 108) return 1 }
    if val == 109 { set_byte(ptr, off, 109) return 1 }
    if val == 110 { set_byte(ptr, off, 110) return 1 }
    if val == 111 { set_byte(ptr, off, 111) return 1 }
    if val == 112 { set_byte(ptr, off, 112) return 1 }
    if val == 113 { set_byte(ptr, off, 113) return 1 }
    if val == 114 { set_byte(ptr, off, 114) return 1 }
    if val == 115 { set_byte(ptr, off, 115) return 1 }
    if val == 116 { set_byte(ptr, off, 116) return 1 }
    if val == 117 { set_byte(ptr, off, 117) return 1 }
    if val == 118 { set_byte(ptr, off, 118) return 1 }
    if val == 119 { set_byte(ptr, off, 119) return 1 }
    if val == 120 { set_byte(ptr, off, 120) return 1 }
    if val == 121 { set_byte(ptr, off, 121) return 1 }
    if val == 122 { set_byte(ptr, off, 122) return 1 }
    if val == 123 { set_byte(ptr, off, 123) return 1 }
    if val == 124 { set_byte(ptr, off, 124) return 1 }
    if val == 125 { set_byte(ptr, off, 125) return 1 }
    if val == 126 { set_byte(ptr, off, 126) return 1 }
    if val == 127 { set_byte(ptr, off, 127) return 1 }
    return 0
}

fn wb_2(ptr, off, val) {
    if val == 128 { set_byte(ptr, off, 128) return 1 }
    if val == 129 { set_byte(ptr, off, 129) return 1 }
    if val == 130 { set_byte(ptr, off, 130) return 1 }
    if val == 131 { set_byte(ptr, off, 131) return 1 }
    if val == 132 { set_byte(ptr, off, 132) return 1 }
    if val == 133 { set_byte(ptr, off, 133) return 1 }
    if val == 134 { set_byte(ptr, off, 134) return 1 }
    if val == 135 { set_byte(ptr, off, 135) return 1 }
    if val == 136 { set_byte(ptr, off, 136) return 1 }
    if val == 137 { set_byte(ptr, off, 137) return 1 }
    if val == 138 { set_byte(ptr, off, 138) return 1 }
    if val == 139 { set_byte(ptr, off, 139) return 1 }
    if val == 140 { set_byte(ptr, off, 140) return 1 }
    if val == 141 { set_byte(ptr, off, 141) return 1 }
    if val == 142 { set_byte(ptr, off, 142) return 1 }
    if val == 143 { set_byte(ptr, off, 143) return 1 }
    if val == 144 { set_byte(ptr, off, 144) return 1 }
    if val == 145 { set_byte(ptr, off, 145) return 1 }
    if val == 146 { set_byte(ptr, off, 146) return 1 }
    if val == 147 { set_byte(ptr, off, 147) return 1 }
    if val == 148 { set_byte(ptr, off, 148) return 1 }
    if val == 149 { set_byte(ptr, off, 149) return 1 }
    if val == 150 { set_byte(ptr, off, 150) return 1 }
    if val == 151 { set_byte(ptr, off, 151) return 1 }
    if val == 152 { set_byte(ptr, off, 152) return 1 }
    if val == 153 { set_byte(ptr, off, 153) return 1 }
    if val == 154 { set_byte(ptr, off, 154) return 1 }
    if val == 155 { set_byte(ptr, off, 155) return 1 }
    if val == 156 { set_byte(ptr, off, 156) return 1 }
    if val == 157 { set_byte(ptr, off, 157) return 1 }
    if val == 158 { set_byte(ptr, off, 158) return 1 }
    if val == 159 { set_byte(ptr, off, 159) return 1 }
    if val == 160 { set_byte(ptr, off, 160) return 1 }
    if val == 161 { set_byte(ptr, off, 161) return 1 }
    if val == 162 { set_byte(ptr, off, 162) return 1 }
    if val == 163 { set_byte(ptr, off, 163) return 1 }
    if val == 164 { set_byte(ptr, off, 164) return 1 }
    if val == 165 { set_byte(ptr, off, 165) return 1 }
    if val == 166 { set_byte(ptr, off, 166) return 1 }
    if val == 167 { set_byte(ptr, off, 167) return 1 }
    if val == 168 { set_byte(ptr, off, 168) return 1 }
    if val == 169 { set_byte(ptr, off, 169) return 1 }
    if val == 170 { set_byte(ptr, off, 170) return 1 }
    if val == 171 { set_byte(ptr, off, 171) return 1 }
    if val == 172 { set_byte(ptr, off, 172) return 1 }
    if val == 173 { set_byte(ptr, off, 173) return 1 }
    if val == 174 { set_byte(ptr, off, 174) return 1 }
    if val == 175 { set_byte(ptr, off, 175) return 1 }
    if val == 176 { set_byte(ptr, off, 176) return 1 }
    if val == 177 { set_byte(ptr, off, 177) return 1 }
    if val == 178 { set_byte(ptr, off, 178) return 1 }
    if val == 179 { set_byte(ptr, off, 179) return 1 }
    if val == 180 { set_byte(ptr, off, 180) return 1 }
    if val == 181 { set_byte(ptr, off, 181) return 1 }
    if val == 182 { set_byte(ptr, off, 182) return 1 }
    if val == 183 { set_byte(ptr, off, 183) return 1 }
    if val == 184 { set_byte(ptr, off, 184) return 1 }
    if val == 185 { set_byte(ptr, off, 185) return 1 }
    if val == 186 { set_byte(ptr, off, 186) return 1 }
    if val == 187 { set_byte(ptr, off, 187) return 1 }
    if val == 188 { set_byte(ptr, off, 188) return 1 }
    if val == 189 { set_byte(ptr, off, 189) return 1 }
    if val == 190 { set_byte(ptr, off, 190) return 1 }
    if val == 191 { set_byte(ptr, off, 191) return 1 }
    return 0
}

fn wb_3(ptr, off, val) {
    if val == 192 { set_byte(ptr, off, 192) return 1 }
    if val == 193 { set_byte(ptr, off, 193) return 1 }
    if val == 194 { set_byte(ptr, off, 194) return 1 }
    if val == 195 { set_byte(ptr, off, 195) return 1 }
    if val == 196 { set_byte(ptr, off, 196) return 1 }
    if val == 197 { set_byte(ptr, off, 197) return 1 }
    if val == 198 { set_byte(ptr, off, 198) return 1 }
    if val == 199 { set_byte(ptr, off, 199) return 1 }
    if val == 200 { set_byte(ptr, off, 200) return 1 }
    if val == 201 { set_byte(ptr, off, 201) return 1 }
    if val == 202 { set_byte(ptr, off, 202) return 1 }
    if val == 203 { set_byte(ptr, off, 203) return 1 }
    if val == 204 { set_byte(ptr, off, 204) return 1 }
    if val == 205 { set_byte(ptr, off, 205) return 1 }
    if val == 206 { set_byte(ptr, off, 206) return 1 }
    if val == 207 { set_byte(ptr, off, 207) return 1 }
    if val == 208 { set_byte(ptr, off, 208) return 1 }
    if val == 209 { set_byte(ptr, off, 209) return 1 }
    if val == 210 { set_byte(ptr, off, 210) return 1 }
    if val == 211 { set_byte(ptr, off, 211) return 1 }
    if val == 212 { set_byte(ptr, off, 212) return 1 }
    if val == 213 { set_byte(ptr, off, 213) return 1 }
    if val == 214 { set_byte(ptr, off, 214) return 1 }
    if val == 215 { set_byte(ptr, off, 215) return 1 }
    if val == 216 { set_byte(ptr, off, 216) return 1 }
    if val == 217 { set_byte(ptr, off, 217) return 1 }
    if val == 218 { set_byte(ptr, off, 218) return 1 }
    if val == 219 { set_byte(ptr, off, 219) return 1 }
    if val == 220 { set_byte(ptr, off, 220) return 1 }
    if val == 221 { set_byte(ptr, off, 221) return 1 }
    if val == 222 { set_byte(ptr, off, 222) return 1 }
    if val == 223 { set_byte(ptr, off, 223) return 1 }
    if val == 224 { set_byte(ptr, off, 224) return 1 }
    if val == 225 { set_byte(ptr, off, 225) return 1 }
    if val == 226 { set_byte(ptr, off, 226) return 1 }
    if val == 227 { set_byte(ptr, off, 227) return 1 }
    if val == 228 { set_byte(ptr, off, 228) return 1 }
    if val == 229 { set_byte(ptr, off, 229) return 1 }
    if val == 230 { set_byte(ptr, off, 230) return 1 }
    if val == 231 { set_byte(ptr, off, 231) return 1 }
    if val == 232 { set_byte(ptr, off, 232) return 1 }
    if val == 233 { set_byte(ptr, off, 233) return 1 }
    if val == 234 { set_byte(ptr, off, 234) return 1 }
    if val == 235 { set_byte(ptr, off, 235) return 1 }
    if val == 236 { set_byte(ptr, off, 236) return 1 }
    if val == 237 { set_byte(ptr, off, 237) return 1 }
    if val == 238 { set_byte(ptr, off, 238) return 1 }
    if val == 239 { set_byte(ptr, off, 239) return 1 }
    if val == 240 { set_byte(ptr, off, 240) return 1 }
    if val == 241 { set_byte(ptr, off, 241) return 1 }
    if val == 242 { set_byte(ptr, off, 242) return 1 }
    if val == 243 { set_byte(ptr, off, 243) return 1 }
    if val == 244 { set_byte(ptr, off, 244) return 1 }
    if val == 245 { set_byte(ptr, off, 245) return 1 }
    if val == 246 { set_byte(ptr, off, 246) return 1 }
    if val == 247 { set_byte(ptr, off, 247) return 1 }
    if val == 248 { set_byte(ptr, off, 248) return 1 }
    if val == 249 { set_byte(ptr, off, 249) return 1 }
    if val == 250 { set_byte(ptr, off, 250) return 1 }
    if val == 251 { set_byte(ptr, off, 251) return 1 }
    if val == 252 { set_byte(ptr, off, 252) return 1 }
    if val == 253 { set_byte(ptr, off, 253) return 1 }
    if val == 254 { set_byte(ptr, off, 254) return 1 }
    if val == 255 { set_byte(ptr, off, 255) return 1 }
    return 0
}



fn write_byte_safe(ptr, off, val) {
    let v = to_u8(val) // SANITIZE NEGATIVES
    if wb_0(ptr, off, v) { return 0 }
    if wb_1(ptr, off, v) { return 0 }
    if wb_2(ptr, off, v) { return 0 }
    if wb_3(ptr, off, v) { return 0 }
    print(999444) // FAILED
    return 0
}


fn emit(state, val) {
    // print(888000) // Emit Start
    // print(state)
    
    // Inline get_qword(state, 510) -> mem
    let mem = 0
    let p = 517
    let k = 8
    while k > 0 {
        let b = get_byte(state, p)
        mem = mem * 256
        mem = mem + b
        p = p - 1
        k = k - 1
    }
    // print(mem)
    
    // Inline get_qword(state, 530) -> cursor
    let cursor = 0
    let p2 = 537
    let k2 = 8
    while k2 > 0 {
        let b2 = get_byte(state, p2)
        cursor = cursor * 256
        cursor = cursor + b2
        p2 = p2 - 1
        k2 = k2 - 1
    }
    
    write_byte_safe(mem, cursor, val)
    set_state(state, 530, cursor + 1)
}

fn gen_iterative(state, node) {
    print(777999) // Gen Iterative Start
    print(state)
    
    // Inline Get Qword 510 Check
    let v_chk = 0
    let p_chk = 510 + 7
    let k_chk = 8
    while k_chk > 0 {
        let b = get_byte(state, p_chk)
        v_chk = v_chk * 256
        v_chk = v_chk + b
        p_chk = p_chk - 1
        k_chk = k_chk - 1
    }
    print(v_chk) // Should matches main's 510
    
    if node == 0 { return 0 }
    
    // Prologue: push rbp; mov rbp, rsp
    emit(state, 85) // push rbp

fn set_int32(state, cursor, val) {
    print(999111) // Set Int32 Start
    print(state)
    print(OFF_CODE_BUF)
    // Inline get_state(state, 510) -> mem
    let mem = 0
    let p = 517
    let k = 8
    while k > 0 {
        let b = get_byte(state, p)
        mem = mem * 256
        mem = mem + b
        p = p - 1
        k = k - 1
    }
    print(mem)
    let v = val
    
    // Byte 0
    let b0 = val_mod_256(v)
    print(999112)
    write_byte_safe(mem, cursor, b0)
    print(999113)
    v = val_div_256(v)
    
    // Byte 1
    let b1 = val_mod_256(v)
    print(999114)
    write_byte_safe(mem, cursor + 1, b1)
    print(999115)
    v = val_div_256(v)
    
    // Byte 2
    let b2 = val_mod_256(v)
    write_byte_safe(mem, cursor + 2, b2)
    v = val_div_256(v)
    
    // Byte 3
    let b3 = val_mod_256(v)
    write_byte_safe(mem, cursor + 3, b3)
    
    print(999222) // Set Int32 End
}

// --- STATE UTILS ---

fn get_qword(ptr, off) {
    let v = 0
    let p = off + 7
    let k = 8
    while k > 0 {
        let b = get_byte(ptr, p)
        // print(777000) print(p) print(b) // Trace byte read
        v = v * 256
        v = v + b
        p = p - 1
        k = k - 1
    }
    return v
}

fn set_qword(ptr, off, val) {
    let v = val
    let p = off
    let k = 8
    while k > 0 { 
        let b = val_mod_256(v)
        write_byte_safe(ptr, p, b)
        v = val_div_256(v)
        p = p + 1
        k = k - 1
    }
}

fn get_state(state, off) { return get_qword(state, off) }
fn set_state(state, off, val) { set_qword(state, off, val) }

// --- SYMBOL TABLE ---

fn sym_add(state, hash) {
    let ptr = get_state(state, 550) // OFF_SYM_PTR
    let cnt = get_state(state, 72) // OFF_SYM_COUNT
    let mem = get_state(state, 500) // OFF_DATA_MEM
    
    let off = ptr + (cnt * 16)
    
    set_qword(mem, off, hash)
    
    // Val (Offset) Assumed on stack top? Stack Depth?
    let depth = get_state(state, 80) // OFF_STACK_DEPTH
    set_qword(mem, off + 8, depth)
    
    set_state(state, 72, cnt + 1)
    set_state(state, 80, depth + 8)
    
    return depth
}

fn sym_find(state, hash) {
    let sym_ptr = get_state(state, 550) // OFF_SYM_PTR
    let cnt = get_state(state, 72)
    let mem = get_state(state, 500)
    
    let i = 0
    while i < cnt {
        let idx = i * 16
        let h = get_qword(sym_ptr, idx)
        if h == hash {
            return get_qword(sym_ptr, idx + 8) // Return offset
        }
        i = i + 1
    }
    return 0 // Not found
}

// --- MEMORY SETUP ---

fn init_memory(state) {
    // 500: OFF_DATA_MEM (Set in main)
    // 510: OFF_CODE_BUF (Set in main)
    
    // 520: OFF_DATA_PTR. Start at 64
    set_state(state, 520, 64) 
    
    // 530: OFF_CODE_CURSOR. Start at 0
    set_state(state, 530, 0)
    
    // 24: OFF_SRC_LEN. Keep at 24? Lex uses offset 24 logic?
    // Lex uses OFF_SRC_LEN constant. If constant is 0...
    // Lex will use 0.
    // I MUST hardcode offsets in lex too.
    
    // 72 -> 560: OFF_SYM_COUNT
    set_state(state, 560, 0)
    
    // 80 -> 570: OFF_STACK_DEPTH
    set_state(state, 570, 0)
    
    // Lex/Parse offsets (If not hardcoded in lex/parse yet):
    // OFF_SRC_LEN = 24. If resolves to 0. 
    // Lex: get_state(state, OFF_SRC_LEN).
    // I need to update Lex? YES.
    
    // For now, I update INIT. 
    // I should create a PLAN to update lex too.
}


fn init_src(state, CAST_SRC_BUF_PTR) {
    let b = CAST_SRC_BUF_PTR
    print(111222) // Init Src Start
    print(b)
    let p = 0
    // fn main { 
    //   let i = 10 
    //   let sum = 0 
    //   while i { 
    //     sum = sum + i 
    //     i = i - 1 
    //   } 
    //   return sum 
    // }
    
    // fn main {
    set_byte(b, p, 102) p=p+1 // f
    set_byte(b, p, 110) p=p+1 // n
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 109) p=p+1 // m
    set_byte(b, p, 97) p=p+1  // a
    set_byte(b, p, 105) p=p+1 // i
    set_byte(b, p, 110) p=p+1 // n
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 123) p=p+1 // {
    set_byte(b, p, 32) p=p+1  // _
    
    // let i = 10
    set_byte(b, p, 108) p=p+1 // l
    set_byte(b, p, 101) p=p+1 // e
    set_byte(b, p, 116) p=p+1 // t
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 105) p=p+1 // i
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 61) p=p+1  // =
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 49) p=p+1  // 1
    set_byte(b, p, 48) p=p+1  // 0
    set_byte(b, p, 32) p=p+1  // _
    
    // let s = 0
    set_byte(b, p, 108) p=p+1 // l
    set_byte(b, p, 101) p=p+1 // e
    set_byte(b, p, 116) p=p+1 // t
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 115) p=p+1 // s
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 61) p=p+1  // =
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 48) p=p+1  // 0
    set_byte(b, p, 32) p=p+1  // _
    
    // while i {
    set_byte(b, p, 119) p=p+1 // w
    set_byte(b, p, 104) p=p+1 // h
    set_byte(b, p, 105) p=p+1 // i
    set_byte(b, p, 108) p=p+1 // l
    set_byte(b, p, 101) p=p+1 // e
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 105) p=p+1 // i
    set_byte(b, p, 32) p=p+1  // _
    
    // > 0
    set_byte(b, p, 62) p=p+1 // >
    set_byte(b, p, 32) p=p+1 // _
    set_byte(b, p, 48) p=p+1 // 0
    set_byte(b, p, 32) p=p+1 // _
    
    set_byte(b, p, 123) p=p+1 // {
    set_byte(b, p, 32) p=p+1  // _
    
    // s = s + i
    set_byte(b, p, 115) p=p+1 // s
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 61) p=p+1  // =
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 115) p=p+1 // s
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 43) p=p+1  // +
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 105) p=p+1 // i
    set_byte(b, p, 32) p=p+1  // _
    
    // i = i - 1
    set_byte(b, p, 105) p=p+1 // i
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 61) p=p+1  // =
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 105) p=p+1 // i
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 45) p=p+1  // -
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 49) p=p+1  // 1
    set_byte(b, p, 32) p=p+1  // _

    // }
    set_byte(b, p, 125) p=p+1 // }
    set_byte(b, p, 32) p=p+1  // _

    // return s
    set_byte(b, p, 114) p=p+1 // r
    set_byte(b, p, 101) p=p+1 // e
    set_byte(b, p, 116) p=p+1 // t
    set_byte(b, p, 117) p=p+1 // u
    set_byte(b, p, 114) p=p+1 // r
    set_byte(b, p, 110) p=p+1 // n
    set_byte(b, p, 32) p=p+1  // _
    set_byte(b, p, 115) p=p+1 // s
    set_byte(b, p, 32) p=p+1  
    
    // }
    set_byte(b, p, 125) p=p+1 // }
    set_byte(b, p, 0)         // EOF
    
    set_state(state, 24, p) // OFF_SRC_LEN = 24
    set_state(state, 32, 0) // OFF_CODE_IDX = 32
    
    print(999888) // Init Src Verify
    print(get_byte(b, 0)) // Should be 102 (f) or 125?
    // First byte written: set_byte(b, p, 102) (f)
    // So 102.
}

// --- AST UTILS (V4 - With Next Pointer) ---

fn node_new(state, type, val) {
    let data_mem = get_state(state, 500) // OFF_DATA_MEM
    let data_ptr = get_state(state, 520) // OFF_DATA_PTR
    
    // Check OOM
    if data_ptr > 190000 {
        print(666002) // DATA OOM
        return 0
    }
    
    let node = data_mem + data_ptr
    
    write_byte_safe(data_mem, data_ptr, type) // +0: Type
    set_qword(data_mem, data_ptr + 1, val)    // +1: Val
    set_qword(data_mem, data_ptr + 9, 0)      // +9: Child
    set_qword(data_mem, data_ptr + 17, 0)     // +17: Next
    
    // Increment Ptr (Node size 25)
    set_state(state, 520, data_ptr + 25)
    
    return data_ptr
}


fn node_child(state, parent, child) {
    let data_mem = get_state(state, 500) // OFF_DATA_MEM
    let cp = parent + 9
    set_qword(data_mem, cp, child)
}

fn node_next(state, node, next) {
    let data_mem = get_state(state, 500) // OFF_DATA_MEM
    let np = node + 17
    set_qword(data_mem, np, next)
}

fn get_node_type(state, node) {
    let data_mem = get_state(state, 500)
    return get_byte(data_mem, node)
}
fn get_node_val(state, node) {
    let data_mem = get_state(state, 500)
    let vp = node + 1
    return get_qword(data_mem, vp)
}
fn get_node_child(state, node) {
    let data_mem = get_state(state, 500)
    let cp = node + 9
    return get_qword(data_mem, cp)
}
fn get_node_next(state, node) {
    let data_mem = get_state(state, 500)
    let np = node + 17
    return get_qword(data_mem, np)
}

// --- LEXER ---

fn peek_char(state) {
    let idx = get_state(state, 32)
    let len = get_state(state, 24)
    if idx == 0 {
        print(600999) // PEEK DEBUG
        print(idx)
        print(len)
        let mem = get_state(state, 540)
        print(mem)
        let v_dbg = get_byte(mem, idx)
        print(v_dbg)
    }
    if idx == len { return 0 }
    let mem = get_state(state, 540) // OFF_SRC_MEM
    return get_byte(mem, idx)
}

fn get_char(state) {
    let c = peek_char(state)
    if c { 
        let idx = get_state(state, 32)
        let n = idx + 1
        set_state(state, 32, n)
    }
    return c
}

fn is_digit(c) {
    if c == 48 { return 1 }
    if c == 49 { return 1 }
    if c == 50 { return 1 }
    if c == 51 { return 1 }
    if c == 52 { return 1 }
    if c == 53 { return 1 }
    if c == 54 { return 1 }
    if c == 55 { return 1 }
    if c == 56 { return 1 }
    if c == 57 { return 1 }
    return 0
}

fn is_alpha(c) {
    // a-z
    if c > 96 {
        if c < 123 { return 1 }
    }
    return 0
}



// --- CONSTANTS ---
// Tokens (Extending v6)
let TOK_EOF = 0
let TOK_FN = 1
let TOK_ID = 2
let TOK_LBRACE = 3
let TOK_RBRACE = 4
let TOK_LET = 5
let TOK_EQ = 6
let TOK_NUM = 7
let TOK_RET = 8
let TOK_IF = 9
let TOK_WHILE = 10
let TOK_PLUS = 11
let TOK_MINUS = 12
let TOK_LT = 13     // <
let TOK_GT = 14     // >
let TOK_EQ_EQ = 15  // ==

// AST Nodes
let NODE_FN = 1
let NODE_BLOCK = 11
let NODE_LET = 20
let NODE_ID = 4
let NODE_NUM = 5
let NODE_RET = 2
let NODE_IF = 4
let NODE_WHILE = 7
let NODE_ASSIGN = 6
let NODE_ADD = 30
let NODE_SUB = 31
let NODE_LT = 40
let NODE_GT = 41
let NODE_EQ = 42

// [Skipping to Lexer changes]

fn lex(state) {
    print(600000) // Trace Lex
    let c = peek_char(state)
    // 32=SPC, 10=LF, 13=CR, 9=TAB
    // 32=SPC, 10=LF, 13=CR, 9=TAB
    let skip = 1
    while skip {
        let matched = 0
        if c == 32 { matched = 1 }
        if c == 10 { matched = 1 }
        if c == 13 { matched = 1 }
        if c == 9 { matched = 1 }
        
        if matched == 1 {
            get_char(state)
            c = peek_char(state)
        } else {
            skip = 0
        }
    }
    
    // EOF
    if c == 0 { 
        set_state(state, 580, 99) // TOK_EOF = 99
        return 0 
    }
    
    print(600001) // Char
    print(c)
    
    if c == 123 { get_char(state) set_state(state, 580, 3) return 0 } // LBRACE
    if c == 125 { get_char(state) set_state(state, 580, 4) return 0 } // RBRACE
    if c == 61 { get_char(state) set_state(state, 580, 61) return 0 } // EQ
    if c == 43 { get_char(state) set_state(state, 580, 11) return 0 } // PLUS
    if c == 45 { get_char(state) set_state(state, 580, 12) return 0 } // MINUS
    
    // Check '<' (60)
    if c == 60 { 
        get_char(state) 
        set_state(state, 580, 13) // TOK_LT
        return 0 
    }
    
    // Check '>' (62)
    if c == 62 { 
        get_char(state) 
        set_state(state, 580, 14) // TOK_GT
        return 0 
    }
    
    // Check '==' vs '='
    if c == 61 {
        get_char(state)
        let next = peek_char(state)
        if next == 61 { // Found second '='
            get_char(state)
            set_state(state, 580, 15) // TOK_EQ_EQ
            return 0
        }
        set_state(state, 580, 6) // TOK_EQ (Assignment)
        return 0
    }
    
    if is_digit(c) == 1 {
        let val = 0
        let looping = 1
        while looping {
            val = (val * 10) + (c - 48)
            get_char(state)
            c = peek_char(state)
            if is_digit(c) == 0 { looping = 0 }
        }
        set_state(state, OFF_CURR_VAL, val)
        set_state(state, 580, TOK_NUM)
        return 0
    }
    
    if is_alpha(c) == 1 {
        let val = 0
        let looping = 1
        while looping {
            val = (val * 33) + c
            get_char(state)
            c = peek_char(state)
            if is_alpha(c) == 0 { looping = 0 }
        }
        
        // fn = 3476
        if val == 3476 { 
            set_state(state, 580, 1) 
            return 0 
        }
        
        // let = 121061
        if val == 121061 { 
            set_state(state, 580, 60) 
            return 0 
        }
        
        // if = 3567
        if val == 3567 { 
            set_state(state, 580, 9) 
            return 0 
        }
        
        // while = 144980057
        if val == 144980057 { 
            set_state(state, 580, 10) 
            return 0 
        }
        
        // return = 4585512800
        if val == 4585512800 { 
            set_state(state, 580, 8) 
            return 0 
        }
        
        print(600002) // TOK_ID
        print(val)
        set_state(state, OFF_CURR_VAL, val) // Store Hash
        set_state(state, 580, TOK_ID)
        return 0
    }
    
    // Unknown
}


fn eat(state, t) {
    let curr = get_state(state, 580)
    
    if curr == t {
        lex(state)
    } else {
        print(999999)
        print(curr)
        print(t)
        while 1 { } // Panic
    }
}


// --- PARSER ---

fn peek_type(state) {
    return get_state(state, 580)
}

fn peek_val(state) {
    return get_state(state, 590)
}


fn parse_term(state) {
    let t = peek_type(state)
    if t == TOK_ID {
        let name = peek_val(state)
        eat(state, TOK_ID)
        return node_new(state, NODE_ID, name)
    }
    if t == TOK_NUM {
        let val = peek_val(state)
        eat(state, TOK_NUM)
        return node_new(state, NODE_NUM, val)
    }
    return 0
}

fn parse_expr(state) {
    let left = parse_term(state)
    
    let t = peek_type(state)
    if t == TOK_PLUS {
        eat(state, TOK_PLUS)
        let right = parse_term(state)
        let node = node_new(state, NODE_ADD, 0)
        node_child(state, node, left)
        node_next(state, left, right)
        return node
    }
    if t == TOK_MINUS {
        eat(state, TOK_MINUS)
        let right = parse_term(state)
        let node = node_new(state, NODE_SUB, 0)
        node_child(state, node, left)
        node_next(state, left, right)
        left = node
        t = peek_type(state)
    }

    // Handle Comparisons
    if t == TOK_LT { // <
        eat(state, TOK_LT)
        let right = parse_expr(state) // Recursive
        let node = node_new(state, NODE_LT, 0)
        node_child(state, node, left)
        node_next(state, left, right)
        return node
    }
    if t == TOK_GT { // >
        eat(state, TOK_GT)
        let right = parse_expr(state)
        let node = node_new(state, NODE_GT, 0)
        node_child(state, node, left)
        node_next(state, left, right)
        return node
    }
    if t == TOK_EQ_EQ { // ==
        eat(state, TOK_EQ_EQ)
        let right = parse_expr(state)
        let node = node_new(state, NODE_EQ, 0)
        node_child(state, node, left)
        node_next(state, left, right)
        return node
    }
    
    return left
}


fn parse_statement(state) {
    let type = peek_type(state)
    // print(700000 + type) 
    
    // LET = 60
    if type == 60 {
        // print(700005) // Enter LET
        eat(state, 60)
        let name = peek_val(state)
        eat(state, 2) // TOK_ID
        eat(state, 61) // TOK_EQ
        let expr = parse_expr(state)
        
        let node = node_new(state, NODE_LET, name)
        node_child(state, node, expr)
        return node
    }
        
    // ASSIGN (ID = ...) TOK_ID = 2
    if type == 2 {
        // print(700002) // Enter ASSIGN
        let name = peek_val(state)
        eat(state, 2) // TOK_ID
        eat(state, 61) // TOK_EQ
        let expr = parse_expr(state)
        let node = node_new(state, NODE_ASSIGN, name)
        node_child(state, node, expr)
        return node
    }

    // IF = 9
    if type == 9 {
        // print(700009) // Enter IF
        eat(state, 9)
        let cond = parse_expr(state)
        
        // Body
        eat(state, 3) // LBRACE
        let body = node_new(state, NODE_BLOCK, 0)
        
        let looping = 1
        let curr = body
        let t = peek_type(state)
        if t == 4 { // RBRACE
             looping = 0
        } else {
             // First stmt
             let stmt = parse_statement(state)
             node_child(state, body, stmt)
             curr = stmt
             
             let inner_loop = 1
             while inner_loop {
                 t = peek_type(state)
                 if t == 4 { inner_loop = 0 }
                 else {
                     let next = parse_statement(state)
                     if next != 0 {
                         node_next(state, curr, next)
                         curr = next
                     } else {
                         inner_loop = 0
                     }
                 }
             }
        }
        eat(state, 4) // RBRACE
        
        let node = node_new(state, NODE_IF, 0)
        node_child(state, node, cond)
        node_next(state, cond, body)
        return node
    }

    // WHILE = 10
    if type == 10 {
        // print(700010) // Enter WHILE
        eat(state, 10)
        let cond = parse_expr(state)
        
        eat(state, 3) // LBRACE
        let body = node_new(state, NODE_BLOCK, 0)
        
        // Body Parsing
        let curr = body
        let t = peek_type(state)
        
        // Check Empty Block
        if t != 4 {
             let stmt = parse_statement(state)
             node_child(state, body, stmt)
             curr = stmt
             
             let inner_loop = 1
             while inner_loop {
                 t = peek_type(state)
                 if t == 4 { inner_loop = 0 }
                 else {
                     let next = parse_statement(state)
                     if next != 0 {
                         node_next(state, curr, next)
                         curr = next
                     } else {
                         inner_loop = 0
                     }
                 }
             }
        }
        eat(state, 4) // RBRACE
        
        let node = node_new(state, NODE_WHILE, 0)
        node_child(state, node, cond)
        node_next(state, cond, body)
        return node
    }

    // RETURN = 8 (Using 8 as per original check, make sure TOK_RET matches)
    // Actually TOK_RET is 5 in header, but 8 here? 
    // Lexer logic check needed. 
    // Assuming 8 was working for 'return'.
    if type == 8 {
        eat(state, 8)
        let val = parse_expr(state)
        let node = node_new(state, NODE_RET, 0)
        node_child(state, node, val)
        return node
    }
    
    return 0
}


// Removed parse_block to avoid forward ref issues






fn parse_func_def(state) {
    print(800000) // Parse Func Def Start
    let t = peek_type(state)
    print(t)
    
    eat(state, 1) // TOK_FN
    print(800001)
    eat(state, 2) // TOK_ID
    print(800002)
    eat(state, 3) // TOK_LBRACE
    print(800003)
    print(NODE_BLOCK) // Check Constant
    let head = node_new(state, NODE_BLOCK, 0)
    print(800004) // Node New Done
    let t = peek_type(state)
    // print(800005) // Peek Done
    
    if t == 4 { // TOK_RBRACE
        eat(state, 4)
        return head
    }
    
    // Parse first statement
    let stmt = parse_statement(state)
    node_child(state, head, stmt)
    let curr = stmt
    
    let looping = 1
    while looping {
        t = peek_type(state)
        // print(555555)
        
        if t == 4 { // TOK_RBRACE
             looping = 0
        } else {
            let next_stmt = parse_statement(state)
            
            if next_stmt != 0 {
                node_next(state, curr, next_stmt)
                curr = next_stmt
            } else {
                 if t == 4 { eat(state, 4) }
                 return head
            }
        }
    }
    eat(state, 4) // TOK_RBRACE
    return head
}

fn check_integrity(state) {
    let mem = get_state(state, OFF_CODE_BUF)
    if mem == 0 {
        print(666999) // CORRUPTION DETECTED
    }
}

// --- CODEGEN ---





fn emit(state, byte) {
    let mem = get_state(state, OFF_CODE_BUF)
    if mem == 0 {
        print(666000) // FATAL: Mem is 0 in emit
        print(state)
        print(OFF_CODE_BUF)
    }
    let cursor = get_state(state, OFF_CODE_CURSOR)
    write_byte_safe(mem, cursor, byte)
    let n = cursor + 1
    set_state(state, OFF_CODE_CURSOR, n)
}

fn emit64(state, val) {
    let v = val
    let k = 8
    while k > 0 { 
        let b = val_mod_256(v)
        v = val_div_256(v)
        emit(state, b)
        k = k - 1
    }
}



fn gen_cmp(state, node, set_opcode) {
    let left = get_node_child(state, node)
    let right = get_node_next(state, left)
    
    // 1. Eval Left -> RAX, Push
    gen_expr(state, left)
    emit(state, 80) // PUSH RAX
    
    // 2. Eval Right -> RAX, Move to RCX
    gen_expr(state, right)
    emit(state, 72) emit(state, 137) emit(state, 193) // MOV RCX, RAX
    
    // 3. Pop Left -> RAX
    emit(state, 88) // POP RAX
    
    // 4. CMP RAX, RCX
    emit(state, 72) emit(state, 57) emit(state, 200) // CMP RAX, RCX (0x48 0x39 0xC8)
    
    // 5. SETcc AL
    emit(state, 15) emit(state, set_opcode) emit(state, 192) // SETcc AL (0x0F <OP> 0xC0)
    
    // 6. MOVZX RAX, AL (Zero extend byte to 64-bit)
    emit(state, 72) emit(state, 15) emit(state, 182) emit(state, 192)
    
    return 0
}

fn gen_expr(state, node) {
    let type = get_node_type(state, node)
    
    if type == NODE_NUM {
        emit(state, 72) emit(state, 184)
        emit64(state, get_node_val(state, node))
        return 0
    }
    
    if type == NODE_ID {
        let vname = get_node_val(state, node)
        let offset = sym_find(state, vname)
        emit(state, 72) emit(state, 139) emit(state, 69)
        emit(state, 256 - offset)
        return 0
    }
    
    if type == NODE_LT {
        gen_cmp(state, node, 156) // SETL (0x9C) = 156
        return 0
    }
    if type == NODE_GT {
        gen_cmp(state, node, 159) // SETG (0x9F) = 159
        return 0
    }
    if type == NODE_EQ {
        gen_cmp(state, node, 148) // SETE (0x94) = 148
        return 0
    }
    
    if type == NODE_ADD {
        let left = get_node_child(state, node)
        let right = get_node_next(state, left)
        
        gen_expr(state, left)
        emit(state, 80) // PUSH RAX
        
        gen_expr(state, right)
        emit(state, 89) // POP RCX
        
        // ADD RAX, RCX (48 01 C8)
        emit(state, 72) emit(state, 1) emit(state, 200)
        return 0
    }
    
    if type == NODE_SUB {
        let left = get_node_child(state, node)
        let right = get_node_next(state, left)
        
        gen_expr(state, left)
        emit(state, 80) // PUSH RAX
        
        gen_expr(state, right)
        emit(state, 89) // POP RCX (RHS)
        
        // SUB RAX, RCX ??? No, we want SUB Left, Right
        // We popped RHS into RCX. Left is on stack... wait.
        // We popped Left into RCX? No.
        // PUSH Left. Gen Right. POP RCX -> RCX is Left. 
        // Wait, typical stack:
        // Eval Left -> RAX. PUSH RAX.
        // Eval Right -> RAX.
        // POP RCX (Left is now in RCX).
        // SUB RCX, RAX -> Result in RCX.
        // MOV RAX, RCX.
        
        // Let's swap:
        // Eval Left -> RAX. PUSH RAX.
        // Eval Right -> RAX. MOV RCX, RAX.
        // POP RAX (Left).
        // SUB RAX, RCX (Left - Right).
        emit(state, 72) emit(state, 137) emit(state, 193) // MOV RCX, RAX
        emit(state, 88) // POP RAX
        emit(state, 72) emit(state, 41) emit(state, 200) // SUB RAX, RCX
        return 0
    }
}

fn gen_stmts(state, block) {
    print(800000) // Gen Stmts Start
    if block {
        print(800001) // Block is valid
        let stmt = get_node_child(state, block)
        print(800002) // First child
        print(stmt)
        
        // ...
        let type = 0
        let t1 = 0
        let t2 = 0
        let t3 = 0
        let patch = 0
        
        while stmt {
            print(800003) // In Loop
            type = get_node_type(state, stmt)
            print(800010 + type) 
            
            // NODE_LET
            if type == NODE_LET {
                t1 = sym_add(state, get_node_val(state, stmt))
                t2 = get_node_child(state, stmt) // Expr
                gen_expr(state, t2)
                emit(state, 72) emit(state, 137) emit(state, 69)
                emit(state, 256 - t1)
            }
            
            // NODE_ASSIGN
            if type == NODE_ASSIGN {
                t1 = get_node_val(state, stmt) // Name hash
                t2 = sym_find(state, t1)       // Offset
                if t2 == 0 {
                    // Symbol not found error?
                }
                t3 = get_node_child(state, stmt) // Expr
                gen_expr(state, t3)
                emit(state, 72) emit(state, 137) emit(state, 69)
                emit(state, 256 - t2)
            }
            
            // NODE_IF
            if type == NODE_IF {
                t1 = get_node_child(state, stmt)  // cond
                t2 = get_node_next(state, t1)     // body
                
                gen_expr(state, t1)
                
                // CMP RAX, 0; JE rel32
                emit(state, 72) emit(state, 131) emit(state, 248) emit(state, 0)
                emit(state, 15) emit(state, 132)
                patch = get_state(state, OFF_CODE_CURSOR)
                emit(state, 0) emit(state, 0) emit(state, 0) emit(state, 0)
                
                gen_stmts(state, t2) // Recursive for IF body
                
                // Backpatch jump offset
                t1 = get_state(state, OFF_CODE_CURSOR)
                t2 = t1 - patch - 4
                t3 = get_state(state, OFF_CODE_BUF)
                
                // Use gen_expr? No, write_byte_safe
                // Inline set_int32 logic
                write_byte_safe(t3, patch, val_mod_256(t2))
                t2 = val_div_256(t2)
                write_byte_safe(t3, patch + 1, val_mod_256(t2))
                t2 = val_div_256(t2)
                write_byte_safe(t3, patch + 2, val_mod_256(t2))
                t2 = val_div_256(t2)
                write_byte_safe(t3, patch + 3, val_mod_256(t2))
            }
            
            // NODE_WHILE
            if type == NODE_WHILE {
                // 1. Label Start
                let loop_start = get_state(state, OFF_CODE_CURSOR)
                
                let cond = get_node_child(state, stmt)
                let body = get_node_next(state, cond)
                
                // 2. Gen Condition
                gen_expr(state, cond)
                
                // 3. JE End (Placeholder)
                emit(state, 72) emit(state, 131) emit(state, 248) emit(state, 0)
                emit(state, 15) emit(state, 132)
                patch = get_state(state, OFF_CODE_CURSOR)
                emit(state, 0) emit(state, 0) emit(state, 0) emit(state, 0)
                
                // 4. Gen Body
                gen_stmts(state, body)
                
                // 5. JMP Start (Backward)
                emit(state, 233) // E9
                let curr = get_state(state, OFF_CODE_CURSOR)
                let jump_target = curr + 4
                let back_off = loop_start - jump_target
                
                // Emit Signed 32-bit (using to_u8 handles negative)
                let v = back_off
                emit(state, to_u8(v))
                
                // Arith Shift Emulation
                v = v / 256
                if back_off < 0 { v = v - 1 } 
                emit(state, to_u8(v))
                
                v = v / 256
                if back_off < 0 { v = v - 1 }
                emit(state, to_u8(v)) // Sign extend
                
                v = v / 256
                if back_off < 0 { v = v - 1 }
                emit(state, to_u8(v)) // Sign extend

                // 6. Backpatch JE
                let loop_end = get_state(state, OFF_CODE_CURSOR)
                let fwd_off = loop_end - patch - 4
                
                let mem = get_state(state, OFF_CODE_BUF)
                write_byte_safe(mem, patch, val_mod_256(fwd_off))
                let t2 = val_div_256(fwd_off)
                write_byte_safe(mem, patch + 1, val_mod_256(t2))
                t2 = val_div_256(t2)
                write_byte_safe(mem, patch + 2, val_mod_256(t2))
                t2 = val_div_256(t2)
                write_byte_safe(mem, patch + 3, val_mod_256(t2))
            }

            // NODE_RET
            if type == NODE_RET {
                t1 = get_node_child(state, stmt)
                gen_expr(state, t1)
                emit(state, 93) emit(state, 195)
            }
            
            stmt = get_node_next(state, stmt)
        }
    }
}

fn gen_iterative(state, root) {
    // Prologue: PUSH RBP; MOV RBP, RSP
    emit(state, 85) emit(state, 72) emit(state, 137) emit(state, 229)
    
    gen_stmts(state, root)
    
    // Epilogue fallback
    emit(state, 93) emit(state, 195)
}

fn dump_code(state) {
    let mem = get_state(state, OFF_CODE_BUF)
    let len = get_state(state, OFF_CODE_CURSOR)
    let i = 0
    let looping = 1
    while looping {
        if i == len { looping = 0 }
        if looping {
            print(get_byte(mem, i))
            i = i + 1
        }
    }
}



fn test_memory(state) {
    print(111999) // TEST MSG
    print(get_state(state, 520)) // Expect 64
    set_state(state, 520, 123)
    let v = get_state(state, 520)
    print(v)
    if v == 123 { print(1) } else { print(0) }
    
    // Test Node Alloc
    let n1 = node_new(state, 1, 11)
    print(n1) // Expect 64 (start) or 123? 
    // If set_state 123 was kept?
    // node_new reads 520.
    // If I successfully wrote 123, then node_new uses 123.
    // print(get_state(state, 520)) // Expect 148
    
    // Reset for real run
    set_state(state, 520, 64)
}

fn main() {
    print(111111) // Start
    let state = alloc(1000000) // 1MB Unified Block
    print(state) 
    
    // Derived Src (Offset 300k)
    let src = state + 300000
    
    // Derived Data (Offset 10k)
    let data = state + 10000
    
    // Code (Separate Exec)
    let code = alloc_exec(200000)
    print(code)
    
    if src == data { return 0 } // Should not happen

    if state == code {
        print(666666) // FATAL: ALIASING
        return 0
    }
    
    // Hardcoded State Map:
    // 500: OFF_DATA_MEM
    // 510: OFF_CODE_BUF
    // 520: OFF_DATA_PTR (Init in init_memory)
    // 530: OFF_CODE_CURSOR
    // 540: OFF_SRC_MEM
    // 550: OFF_SYM_PTR
    
    set_state(state, 540, src)
    set_state(state, 500, data)
    set_state(state, 510, code)
    
    // Set Sym Table Ptr
    set_state(state, 550, data + 9000) 
    
    init_memory(state)
    init_src(state, src)
    
    print(111333) // PEEK Check
    print(peek_char(state))
    
    lex(state) 
// ...
    
    let root = parse_func_def(state)
    print(222222) // Parsed
    
    print(998998) // Check Code Buf Before Gen
    print(state)
    print(get_state(state, 510))
    
    gen_iterative(state, root)
    print(333333) // Compiled
    dump_code(state)
    return 0
}



