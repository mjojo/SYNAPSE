// ============================================================
// SYNAPSE SELF-HOSTED CODEGEN V1 (Phase 33)
// AST -> x64 Machine Code
// ============================================================

// --- 1. CONSTANTS ---
let NODE_PROG  = 1
let NODE_FN    = 2
let NODE_BLOCK = 3
let NODE_LET   = 4
let NODE_NUM   = 5
let NODE_RET   = 7 // Return node

// x64 Opcodes
let OP_PUSH_RBP = 85  // 0x55
let OP_MOV_RBP  = 72  // 0x48 0x89 0xE5 (Prefix)
let OP_MOV_RAX  = 184 // 0xB8 (MOV RAX, imm64) - part of 48 B8...
let OP_POP_RBP  = 93  // 0x5D
let OP_RET      = 195 // 0xC3

// --- 2. GLOBAL MEMORY ---
// AST Arena
let ast_arena = alloc(4000)
let ast_ptr = ast_arena

// Code Buffer (Where we write machine code)
let code_buf = alloc_bytes(1024)
let code_cursor = 0

// --- 3. AST BUILDER ---
fn ast_new(type, val) {
    let node = ast_ptr
    node[0] = type
    node[1] = val
    node[2] = 0 // Child
    node[3] = 0 // Sibling
    ast_ptr = alloc(32) // Allocate next node
    return node
}

fn ast_child(parent, child) { parent[2] = child }

// --- 4. CODE EMITTER (Byte Generator) ---
// Write 1 byte
fn emit(byte_val) {
    set_byte(code_buf, code_cursor, byte_val)
    code_cursor = code_cursor + 1
}

// Write 8 bytes (64-bit number, little-endian)
fn emit64(val) {
    // Byte 0
    let b = val % 256
    emit(b)
    val = val / 256
    
    // Byte 1
    b = val % 256
    emit(b)
    val = val / 256
    
    // Byte 2
    b = val % 256
    emit(b)
    val = val / 256
    
    // Byte 3
    b = val % 256
    emit(b)
    val = val / 256
    
    // Bytes 4-7 (Just 0s for this test)
    emit(0)
    emit(0)
    emit(0)
    emit(0)
}

// Generate Function Prologue
fn gen_prologue() {
    // PUSH RBP (0x55)
    emit(85)
    
    // MOV RBP, RSP (0x48 0x89 0xE5)
    emit(72)  // 0x48
    emit(137) // 0x89
    emit(229) // 0xE5
}

// Generate Function Epilogue
fn gen_epilogue() {
    // POP RBP (0x5D)
    emit(93)
    
    // RET (0xC3)
    emit(195)
}

// --- 5. CODEGEN LOGIC (Traverser) ---
fn gen_num(node) {
    let val = node[1]
    
    // MOV RAX, imm64 (0x48 0xB8 + 8 bytes)
    emit(72)  // 0x48 (REX.W)
    emit(184) // 0xB8 (MOV RAX)
    emit64(val)
}

fn gen_ret(node) {
    let expr = node[2] // Child
    if expr[0] == NODE_NUM {
        gen_num(expr)
    }
    gen_epilogue()
}

fn gen_block(node) {
    let stmt = node[2] // Child
    if stmt != 0 {
        if stmt[0] == NODE_RET {
            gen_ret(stmt)
        }
    }
}

fn gen_fn(node) {
    gen_prologue()
    let body = node[2] 
    if body != 0 {
        gen_block(body)
    } else {
        gen_epilogue()
    }
}

// --- 6. HEX DUMPER (Verification) ---
fn print_hex() {
    let i = 0
    while i < code_cursor {
        let b = get_byte(code_buf, i)
        print(b)
        i = i + 1
    }
}

// --- 7. MAIN ---
fn main() {
    print(111111) // CODEGEN START
    
    // 1. Build AST Manually
    // Code: fn main { return 42 }
    
    // Node: NUM 42
    let n_num = ast_new(NODE_NUM, 42)
    
    // Node: RET (child = NUM)
    let n_ret = ast_new(NODE_RET, 0)
    ast_child(n_ret, n_num)
    
    // Node: BLOCK (child = RET)
    let n_block = ast_new(NODE_BLOCK, 0)
    ast_child(n_block, n_ret)
    
    // Node: FN main (child = BLOCK)
    let n_fn = ast_new(NODE_FN, 1000)
    ast_child(n_fn, n_block)
    
    // 2. Generate Code
    gen_fn(n_fn)
    
    print(222222) // GENERATED BYTES:
    
    // 3. Print Bytes
    print_hex()
    
    print(333333) // DONE
}
