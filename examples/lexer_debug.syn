// lexer_debug.syn - Tracing the infinite loop

fn is_digit(c) {
    if (c > 47) {
        if (c < 58) { return 1 }
    }
    return 0
}

fn is_alpha(c) {
    print(c) 
    // a-z
    if (c > 96) {
        if (c < 123) { return 1 }
    }
    return 0
}

fn is_space(c) {
    if (c == 32) { return 1 }
    if (c == 10) { return 1 }
    return 0
}

fn scan(source) {
    puts("[DEBUG] Starting Scan...")
    
    let i = 0
    let len = strlen(source)
    let safety = 0
    
    while (i < len) {
        // Use 'let' for all inner logic vars to ensure clean scope/slots
        let c = get_byte(source, i)
        
        puts("--- Loop Iteration ---")
        print(i)
        print(c)
        
        // Check Space (Inline)
        let check_space = 0
        if (c == 32) { let check_space = 1 }
        if (c == 10) { let check_space = 1 }
        
        if (check_space) {
            puts("  -> Space")
            // Use ASSIGNMENT for i to avoid infinite loop shadowing
            i = i + 1
        } else {
            // Check Alpha (Inline)
            let check_alpha = 0
            if (c > 96) {
                if (c < 123) { let check_alpha = 1 }
            }
            
            if (check_alpha) {
                puts("  -> Identifier Start")
                
                let loop_inner = 1
                while (loop_inner) {
                    i = i + 1
                    let c = get_byte(source, i)
                    
                    let still_inner = 0
                    if (c > 96) {
                        if (c < 123) { let still_inner = 1 }
                    }
                    
                    if (still_inner) {
                        // continue
                    } else {
                        let loop_inner = 0
                    }
                }
                puts("  -> Identifier End")
                
            } else {
                // Check Digit
                let check_digit = 0
                if (c > 47) {
                    if (c < 58) { let check_digit = 1 }
                }
                
                if (check_digit) {
                    puts("  -> Number Start")
                    
                    let loop_inner = 1
                    while (loop_inner) {
                        i = i + 1
                        let c = get_byte(source, i)
                        
                        let still_inner = 0
                        if (c > 47) {
                            if (c < 58) { let still_inner = 1 }
                        }
                        
                        if (still_inner) {
                            // continue
                        } else {
                            let loop_inner = 0
                        }
                    }
                    puts("  -> Number End")
                } else {
                    puts("  -> Operator")
                    i = i + 1
                }
            }
        }
        
        let safety = safety + 1
        if (safety > 50) {
            puts("[EMERGENCY] Safety break triggered!")
            return 0
        }
    }
    
    puts("[SUCCESS] Scan complete.")
    return 0
}

fn main() {
    // Phase 26 allows us to use string literals!
    // But we need a mutable buffer for safety if we plan to modify it (not needed here)
    // Let's just pass the literal directly.
    
    let code = "let x = 123"
    
    puts("Code to scan:")
    puts(code)
    
    scan(code)
    
    return 0
}
